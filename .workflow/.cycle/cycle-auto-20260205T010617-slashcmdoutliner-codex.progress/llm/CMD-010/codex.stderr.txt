Reading prompt from stdin...
OpenAI Codex v0.93.0 (research preview)
--------
workdir: C:\Project\Claude-Code-Workflow
model: gpt-5.2
provider: codex
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c2a06-6624-7f23-94d3-b0daef07d512
--------
user
Use the repo skill: slash-command-outliner (path: .codex/skills/slash-command-outliner).

Cycle: cycle-auto-20260205T010617-slashcmdoutliner-codex
Command: CMD-010

Input requirement doc (non-leaky): `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/requirements/CMD-010.requirements.md`

Write the following output files (create directories as needed) under `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs`:
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md`

Hard rules (P0):
- Follow templates: .codex/skills/slash-command-outliner/templates/*
- Follow gates: .codex/skills/slash-command-outliner/specs/quality-gates.md
- Evidence tables MUST pass: node .codex/skills/slash-command-outliner/scripts/verify-evidence.js
- Never label a pointer as Existing unless it is verifiable in the repo now.
- For ANY pointer row, provide dual-source evidence:
  - docs: .claude/commands/**.md / <real heading text>
  - ts: ccw/src/** / <literal anchor string present in file>
- Avoid placeholders like TBD/N/A in evidence rows; if unsure, mark as Planned and add Verify steps.

Keep the written files concise; do not write extra files unless necessary.

deprecated: `[features].web_search_request` is deprecated. Use `web_search` instead.
  Set `web_search` to `"live"`, `"cached"`, or `"disabled"` in config.toml.
mcp: ace-tool starting
mcp: ccw-tools starting
mcp: exa starting
mcp: ccw-tools ready
mcp: ace-tool ready
mcp: exa ready
mcp startup: ready: ccw-tools, ace-tool, exa




thinking
**Considering file creation methods**

I‚Äôm planning to use PowerShell to run commands and set UTF8 encoding for output files. For creating new files, I think using `write_file` is straightforward, but the instruction says to prioritize `apply_patch` for routine text edits. Though creating new files with `apply_patch` is possible, it might be heavier. So perhaps it‚Äôs better to stick with `write_file` for new files and save `apply_patch` for future modifications. I‚Äôll also check templates and required formats along the way!
thinking
**Evaluating file reading tools**

It looks like there's no `read_file` tool available, but I can use the `shell_command` to run `Get-Content`. However, the instructions suggest avoiding shell commands when MCP tools are accessible. Since I only have `mcp search_context` and `smart_search`, I might go with using `Get-Content -Raw` for file reading. I‚Äôll start by using `mcp search_context` to find relevant documentation and code patterns. Then, I‚Äôll inspect existing commands and fill my evidence tables accordingly. Lastly, I‚Äôll check the SKILL.md for the expected output structure to guide the project.
thinking
**Organizing file reading tasks**

I need to use `Get-Content -Raw` to read file content. I‚Äôll review the templates in the `.codex/skills/slash-command-outliner/templates/` directory, focusing on relevant ones like `spec.json.template`. Using the shell `Get-ChildItem` command might help, but I should probably start with the MCP tools and use `smart_search` to find files in that directory. After gathering context, I‚Äôll read the quality gates file and the verify-evidence script. Finally, I‚Äôll check the requirements document and ensure my output files align with expected markdown formats for verification.
thinking
**Planning file verification and adjustment**

I‚Äôll run the verification process and make adjustments until everything passes. I need to ensure that only the required output files are generated, without adding extras. The verify script may read `generated-slash-outline.md` or `references.json`, so I should look into the skill instructions. I can explore the skill files using `smart_search` to find and read them. While I could execute commands in parallel to handle listing templates and reading documents, using shell commands seems easier for the known files. Now, I‚Äôll run the initial commands to gather the relevant file list.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/SKILL.md' in C:\Project\Claude-Code-Workflow succeeded in 307ms:
---
name: slash-command-outliner
description: Codex version of slash-command-outliner. Generate CCW-aligned slash command development outlines from a requirement/spec doc, validated via corpus-wide iteration and non-regression. Triggers on "slash command outliner", "slash ÂëΩ‰ª§Â§ßÁ∫≤", "slash ÂëΩ‰ª§ÁîüÊàêÂô®", "ÂëΩ‰ª§Â§ßÁ∫≤".
allowed-tools: Read, Write, AskUserQuestion, Task, Bash, TodoWrite, mcp__ace-tool__search_context
---

# Slash Command Outliner (Codex)

Input a **slash command requirement/spec document**. Output a **CCW-aligned, end-to-end development outline** (Slash MD outline + Agent MD outline) plus a **gap-report** that compares against reference implementations and CCW server/tooling corpus. Improve quality by iterating across **all** existing commands with **non-regression snapshots**.

This skill is designed to be **precise** (no fluff) and **stable** (non-regression gate).

## Canonical Workflow (Phases)

1) `phases/01-collect-spec.md`  
2) `phases/02-retrieve-and-rank-references.md`  
3) `phases/03-generate-outlines.md`  
4) `phases/04-gap-report-and-iterate.md`  
5) `phases/05-regression-and-closure.md`

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/specs/quality-gates.md' in C:\Project\Claude-Code-Workflow succeeded in 311ms:
# Quality Gates (Non-regression First)

## P0 Gates (Must Pass)

P0 failure means ‚Äúnot CCW-aligned‚Äù and blocks completion.

1) **Frontmatter completeness**
   - `name`, `description`, `allowed-tools` must exist
   - `argument-hint` optional but recommended for non-trivial commands
2) **Allowed-tools correctness**
   - no tools outside the supported CCW set for the intended workflow
   - no missing tools required by the described behavior
3) **Core sections present**
   - at least: `Overview`, `Usage`, `Execution Process`, `Output/Artifacts`, `Error Handling`
4) **No broken artifact references**
   - referenced paths must be either created by the command or explicitly documented as pre-existing

5) **Implementation pointers must be evidence-based (Existing vs Planned)**
   - Every implementation pointer (file/module/CLI subcommand/tool entry) MUST be labeled:
     - `Existing`: verifiable in repo now
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-ChildItem -Recurse .codex/skills/slash-command-outliner/templates | Select-Object FullName' in C:\Project\Claude-Code-Workflow succeeded in 323ms:

[32;1mFullName[0m
[32;1m--------[0m
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\templates\agent-outline.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\templates\gap-report.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\templates\slash-command-outline.md

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/requirements/CMD-010.requirements.md' in C:\Project\Claude-Code-Workflow succeeded in 309ms:
# Requirement (non-leaky): /issue:convert-to-plan

## Source

- Command doc (oracle, do not paste full contents into spec): `.claude/commands/issue/convert-to-plan.md`

## Command Identity

- group: issue
- name: convert-to-plan
- description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
- argument-hint: [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
- allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)

## Structure Hints (Headings Only)

  - Auto Mode
- Issue Convert-to-Plan Command (/issue:convert-to-plan)
  - Overview
  - Quick Reference

thinking
**Preparing project outlines**

I have the requirement document summarized for the `/issue:convert-to-plan` task, and now I need to generate an outline. First, I'll look at the templates for the slash command outline, agent outline, and gap report. It seems essential to create `spec.json` and `references.json` based on existing scripts or the input format. I'll check the phase documentation and scripts while ensuring we verify the evidence. So, let‚Äôs examine the templates and scripts carefully.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/templates/slash-command-outline.md' in C:\Project\Claude-Code-Workflow succeeded in 304ms:
---
name: {{command.name}}
description: {{command.description}}
argument-hint: "{{command.argument_hint}}"
allowed-tools: {{command.allowed_tools_csv}}
group: {{command.group}}
---

# {{command.title}}

## Overview

- Goal: {{intent.primary_user_value}}
- Command: `/{{command.group}}:{{command.name}}`

## Usage

```bash
/{{command.group}}:{{command.name}} {{command.usage_args}}
```
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/templates/agent-outline.md' in C:\Project\Claude-Code-Workflow succeeded in 307ms:
# Agent Outline: {{command.group}}:{{command.name}}

## Purpose

Implement and/or evolve the slash command according to CCW conventions with minimal regressions.

## Execution Model

- Default: incremental, testable changes
- Use ACE-tool to find existing patterns before adding new abstractions

## State & Artifacts

- Session folder (if used): `.workflow/...`
- Required outputs:
  - Slash MD (command doc)
  - Any scripts/modules referenced by the command
  - Validation notes / regression snapshots

## Tooling
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/templates/gap-report.md' in C:\Project\Claude-Code-Workflow succeeded in 313ms:
# Gap Report: {{command.group}}:{{command.name}}

## Reference

- Selected reference: {{reference.slash}} (`{{reference.file_path}}`)

## P0 Gaps (Must Fix)

{{gaps.p0}}

## P1 Gaps (Should Fix)

{{gaps.p1}}

## P2 Gaps (Optional)

{{gaps.p2}}

## Implementation Pointers (Evidence)

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-ChildItem -Recurse .codex/skills/slash-command-outliner/phases | Select-Object FullName' in C:\Project\Claude-Code-Workflow succeeded in 343ms:

[32;1mFullName[0m
[32;1m--------[0m
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\phases\01-collect-spec.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\phases\02-retrieve-and-rank-references.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\phases\03-generate-outlines.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\phases\04-gap-report-and-iterate.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\phases\05-regression-and-closure.md

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-ChildItem -Recurse .codex/skills/slash-command-outliner/scripts | Select-Object FullName' in C:\Project\Claude-Code-Workflow succeeded in 327ms:

[32;1mFullName[0m
[32;1m--------[0m
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\lib
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\derive-spec.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\gap-report.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\generate-outline.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\README.md
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\regress-all.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\scan-corpus.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\verify-evidence.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\verify-evidence.test.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\lib\command-md.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\lib\implementation-hints.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\lib\pipeline.js
C:\Project\Claude-Code-Workflow\.codex\skills\slash-command-outliner\scripts\lib\snapshots.js


thinking
**Reviewing project specifications**

I need to check the phase documentation to understand the spec and references format. I‚Äôll take a quick look at those phases. Also, it's important to inspect the scripts to know the expected output format and the structure of the evidence table. I plan to open the scripts/README and verify-evidence files for their requirements. Using shell get-content will help me access that information smoothly.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/phases/01-collect-spec.md' in C:\Project\Claude-Code-Workflow succeeded in 310ms:
# Phase 01: Collect Spec (No Leakage)

## Goal

Turn a human requirement/rules document into a **minimal, structured spec** that is sufficient to generate:

- Slash command outline (CCW command MD skeleton)
- Agent outline (execution + tools + state)

Do **not** copy/paste existing implementation docs as input; treat them as oracle only during gap analysis.

## Required Inputs (ask if missing)

1. Command identity:
   - `group` (workflow|issue|learn|cli|other)
   - `name` (kebab-case)
   - `description` (one sentence)
   - `argument-hint` (optional)
2. Allowed tools:
   - exact list for frontmatter `allowed-tools`
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/phases/02-retrieve-and-rank-references.md' in C:\Project\Claude-Code-Workflow succeeded in 300ms:
# Phase 02: Retrieve + Rank References

## Goal

Find the closest existing commands and extract **reusable patterns** without copying full content.

## Steps

1) Use `mcp__ace-tool__search_context` to recall similar commands and relevant tooling code.
2) Produce Top N candidates (default N=5) with deterministic scoring:
   - same `group` / command family
   - similar interaction model (AskUserQuestion, multi-round loop, etc.)
   - similar artifacts (writes to `.workflow/*`, `.claude/*`, etc.)
   - similar allowed-tools surface
3) Require user confirmation for Top 1 (high-confidence can be preselected but must be overridable).

## Output

Write:
- `specs/outputs/references.json`
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/phases/03-generate-outlines.md' in C:\Project\Claude-Code-Workflow succeeded in 301ms:
# Phase 03: Generate Outlines (Slash MD + Agent MD)

## Goal

Generate:
- a **Slash command MD outline** that matches CCW conventions (frontmatter + required sections)
- an **Agent outline** that explains execution model, state, and validation strategy

Use templates; keep output concise and implementation-oriented.

## Inputs

- `specs/outputs/spec.json`
- `specs/outputs/references.json` (selected reference)
- Rules: `../specs/quality-gates.md`

## Output Files

- `specs/outputs/generated-slash-outline.md` (based on `../templates/slash-command-outline.md`)
- `specs/outputs/generated-agent-outline.md` (based on `../templates/agent-outline.md`)
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/phases/04-gap-report-and-iterate.md' in C:\Project\Claude-Code-Workflow succeeded in 322ms:
# Phase 04: Gap Report + Iterate

## Goal

Compare the generated outlines against:
1) The selected reference command implementation (oracle)
2) The CCW server/tooling corpus (routes, mcp tools, cli internals)

Then propose the smallest set of changes to close gaps.

## Inputs

- `specs/outputs/generated-slash-outline.md`
- `specs/outputs/generated-agent-outline.md`
- `specs/outputs/references.json`
- Tooling scope: `../specs/corpus-scope.md`

## Output

Write:
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/phases/05-regression-and-closure.md' in C:\Project\Claude-Code-Workflow succeeded in 306ms:
# Phase 05: Regression + Closure

## Goal

Make sure improvements do not regress previously-validated commands (non-regression).

## What to Update (Cycle Mode)

When iterating against the full corpus:
- Update per-command status in `corpus-manifest.json`
- Check off `TODO_LIST.md` items
- Save snapshots in `regression/expected/` for commands marked completed
- Write snapshot diffs into `regression/diff/` and block on unexpected changes

## Non-regression Policy

See `../specs/quality-gates.md`.

## Completion Criteria


thinking
**Creating schema files**

I need to create `spec.json` and `references.json` using the schema from `specs/spec-input.md`. First, I'll open up `spec-input.md` to check out the structure. Then I might also look into `corpus-scope` to ensure I'm getting all the necessary context. It feels like there are several steps, but I‚Äôm curious about how to get everything lined up correctly! Let's explore this together.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/specs/spec-input.md' in C:\Project\Claude-Code-Workflow succeeded in 303ms:
# Spec Input (Schema + Rules)

The spec is the only ‚Äúsource input‚Äù for outline generation. It must be **minimal** and **non-leaky**.

## Minimal JSON Schema (informal)

```json
{
  "command": {
    "group": "workflow|issue|learn|cli|other",
    "name": "kebab-case",
    "description": "one sentence",
    "argument_hint": "[--flag] \"args\"",
    "allowed_tools": ["Read(*)", "Write(*)"]
  },
  "intent": {
    "type": "analyze|plan|execute|brainstorm|manage|utility",
    "interaction": "single-shot|iterative|loop",
    "primary_user_value": "what this command accomplishes"
  },
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/specs/corpus-scope.md' in C:\Project\Claude-Code-Workflow succeeded in 304ms:
# Corpus Scope (All Commands + Tooling)

## Slash Command Corpus (Must Cover 100%)

- `.claude/commands/**/*.md`
  - exclude: `node_modules/`
  - exclude: `_disabled/`

## Server/Tooling Capability Corpus (Must Be Referenced in Gap Analysis)

These are not ‚Äúslash command targets‚Äù, but are required to detect hidden dependencies:

- `ccw/src/server/routes/**/*`
- `ccw/src/mcp-server/**/*`
- `ccw/src/tools/**/*`
- `ccw/src/commands/**/*`


exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/scripts/README.md' in C:\Project\Claude-Code-Workflow succeeded in 303ms:
# Slash Command Outliner Scripts

All scripts are deterministic (no LLM). They exist to prove corpus coverage and enforce non-regression.

## Common

Run from repo root.

## Scan corpus (rebuild a command list)

```bash
node .codex/skills/slash-command-outliner/scripts/scan-corpus.js --root=.claude/commands --out=.workflow/.scratchpad/commands.json
```

## Regress all commands (cycle mode)

```bash
node .codex/skills/slash-command-outliner/scripts/regress-all.js --cycle-id=cycle-v1-20260203T001806-slashcmdoutliner-qmhuep
```

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content -Raw .codex/skills/slash-command-outliner/scripts/verify-evidence.js' in C:\Project\Claude-Code-Workflow succeeded in 304ms:
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

export function usage() {
  console.log(
    [
      'Usage:',
      '  node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<path.md> [--file=<path2.md> ...]',
      '',
      'Behavior:',
      '  - Extracts evidence tables from markdown (gap-report and/or outline)',
      '  - Enforces evidence-based gates:',
      '    - Each row must label Status as Existing or Planned',
      '    - Evidence must include BOTH docs and ts anchors:',
      '      - docs: .claude/commands/**.md / <section heading>',
      '      - ts: ccw/src/** / <function|case|pattern>',
      '    - Existing rows must point to verifiable pointers (paths must exist when pointer looks like a path)',
      '',
      'Notes:',
tool ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Locate implementations and docs for /issue:convert-to-plan and related commands. Keywords: convert-to-plan, lite-plan, workflow session, issue solution schema, .workflow/.cycle, issue solutions, /issue:* command router, ccw/src commands registry."})
ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Locate implementations and docs for /issue:convert-to-plan and related commands. Keywords: convert-to-plan, lite-plan, workflow session, issue solution schema, .workflow/.cycle, issue solutions, /issue:* command router, ccw/src commands registry."}) success in 6.92s:
{
  "content": [
    {
      "text": "The following code sections were retrieved:\nPath: .claude\\commands\\issue\\convert-to-plan.md\n     1\t---\r\n     2\tname: convert-to-plan\r\n     3\tdescription: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions\r\n     4\targument-hint: \"[-y|--yes] [--issue <id>] [--supplement] <SOURCE>\"\r\n     5\tallowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)\r\n     6\t---\r\n     7\t\r\n     8\t## Auto Mode\r\n     9\t\r\n    10\tWhen `--yes` or `-y`: Skip confirmation, auto-create issue and bind solution.\r\n    11\t\r\n    12\t# Issue Convert-to-Plan Command (/issue:convert-to-plan)\r\n    13\t\r\n    14\t## Overview\r\n    15\t\r\n    16\tConverts various planning artifact formats into issue workflow solutions with intelligent detection and automatic binding.\r\n    17\t\r\n    18\t**Supported Sources** (auto-detected):\r\n    19\t- **lite-plan**: `.workflow/.lite-plan/{slug}/plan.json`\r\n    20\t- **workflow-session**: `WFS-xxx` ID or `.workflow/active/{session}/` folder\r\n    21\t- **markdown**: Any `.md` file with implementation/task content\r\n    22\t- **json**: Direct JSON files matching plan-json-schema\r\n    23\t\r\n    24\t## Quick Reference\r\n    25\t\r\n    26\t```bash\r\n    27\t# Convert lite-plan to new issue (auto-creates issue)\r\n    28\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth-2026-01-25\"\r\n    29\t\r\n    30\t# Convert workflow session to existing issue\r\n    31\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    32\t\r\n    33\t# Supplement existing solution with additional tasks\r\n    34\t/issue:convert-to-plan \"./docs/additional-tasks.md\" --issue ISS-001 --supplement\r\n    35\t\r\n    36\t# Auto mode - skip confirmations\r\n    37\t/issue:convert-to-plan \".workflow/.lite-plan/my-plan\" -y\r\n    38\t```\r\n    39\t\r\n    40\t## Command Options\r\n    41\t\r\n    42\t| Option | Description | Default |\r\n    43\t|--------|-------------|---------|\r\n    44\t| `<SOURCE>` | Planning artifact path or WFS-xxx ID | Required |\r\n    45\t| `--issue <id>` | Bind to existing issue instead of creating new | Auto-create |\r\n    46\t| `--supplement` | Add tasks to existing solution (requires --issue) | false |\r\n    47\t| `-y, --yes` | Skip all confirmations | false |\r\n    48\t\r\n    49\t## Core Data Access Principle\r\n    50\t\r\n    51\t**‚ö†Ô∏è Important**: Use CLI commands for all issue/solution operations.\r\n    52\t\r\n    53\t| Operation | Correct | Incorrect |\r\n    54\t|-----------|---------|-----------|\r\n    55\t| Get issue | `ccw issue status <id> --json` | Read issues.jsonl directly |\r\n    56\t| Create issue | `ccw issue init <id> --title \"...\"` | Write to issues.jsonl |\r\n    57\t| Bind solution | `ccw issue bind <id> <sol-id>` | Edit issues.jsonl |\r\n    58\t| List solutions | `ccw issue solutions --issue <id> --brief` | Read solutions/*.jsonl |\r\n    59\t\r\n    60\t## Solution Schema Reference\r\n    61\t\r\n    62\tTarget format for all extracted data (from solution-schema.json):\r\n...\n    92\t\r\n    93\ttype Action = 'Create' | 'Update' | 'Implement' | 'Refactor' | 'Add' | 'Delete' | 'Configure' | 'Test' | 'Fix';\r\n    94\t```\r\n    95\t\r\n    96\t## Implementation\r\n    97\t\r\n    98\t### Phase 1: Parse Arguments & Detect Source Type\r\n    99\t\r\n   100\t```javascript\r\n   101\tconst input = userInput.trim();\r\n   102\tconst flags = parseFlags(userInput);  // --issue, --supplement, -y/--yes\r\n   103\t\r\n   104\t// Extract source path (first non-flag argument)\r\n   105\tconst source = extractSourceArg(input);\r\n   106\t\r\n   107\t// Detect source type\r\n   108\tfunction detectSourceType(source) {\r\n   109\t  // Check for WFS-xxx pattern (workflow session ID)\r\n   110\t  if (source.match(/^WFS-[\\w-]+$/)) {\r\n   111\t    return { type: 'workflow-session-id', path: `.workflow/active/${source}` };\r\n   112\t  }\r\n...\n   194\t\r\n   195\t  return {\r\n   196\t    title: plan.summary?.split('.')[0]?.trim() || 'Untitled Plan',\r\n   197\t    description: plan.summary,\r\n   198\t    approach: plan.approach,\r\n   199\t    tasks: plan.tasks.map(t => ({\r\n   200\t      id: t.id,\r\n   201\t      title: t.title,\r\n   202\t      scope: t.scope || '',\r\n   203\t      action: t.action || 'Implement',\r\n   204\t      description: t.description || t.title,\r\n   205\t      modification_points: t.modification_points || [],\r\n   206\t      implementation: Array.isArray(t.implementation) ? t.implementation : [t.implementation || ''],\r\n   207\t      test: t.verification ? {\r\n   208\t        unit: t.verification.unit_tests,\r\n   209\t        integration: t.verification.integration_tests,\r\n   210\t        commands: t.verification.manual_checks\r\n   211\t      } : {},\r\n   212\t      acceptance: {\r\n   213\t        criteria: Array.isArray(t.acceptance) ? t.acceptance : [t.acceptance || ''],\r\n   214\t        verification: t.verification?.manual_checks || []\r\n   215\t      },\r\n   216\t      depends_on: t.depends_on || [],\r\n   217\t      priority: 3\r\n   218\t    })),\r\n...\n   249\t\r\n   250\t  // Load all task JSONs from .task folder\r\n   251\t  const taskFiles = Glob({ pattern: `${sessionPath}/.task/IMPL-*.json` });\r\n   252\t  const tasks = taskFiles.map(f => {\r\n   253\t    const taskJson = Read(f);\r\n   254\t    const task = JSON.parse(taskJson);\r\n   255\t    return {\r\n   256\t      id: task.id?.replace(/^IMPL-0*/, 'T') || 'T1',  // IMPL-001 ‚Üí T1\r\n   257\t      title: task.title,\r\n   258\t      scope: task.scope || inferScopeFromTask(task),\r\n   259\t      action: capitalizeAction(task.type) || 'Implement',\r\n   260\t      description: task.description,\r\n   261\t      modification_points: task.implementation?.modification_points || [],\r\n   262\t      implementation: task.implementation?.steps || [],\r\n   263\t      test: task.implementation?.test || {},\r\n   264\t      acceptance: {\r\n   265\t        criteria: task.acceptance_criteria || [],\r\n   266\t        verification: task.verification_steps || []\r\n   267\t      },\r\n...\n   327\t      \"implementation\": [\"step 1\", \"step 2\"],\r\n   328\t      \"acceptance\": [\"criteria 1\", \"criteria 2\"]\r\n   329\t    }\r\n   330\t  ]\r\n   331\t}\r\n   332\tCONSTRAINTS: Output ONLY valid JSON - no markdown, no explanation | Action must be one of: Create, Update, Implement, Refactor, Add, Delete, Configure, Test, Fix | Tasks must have id, title, scope, action, implementation (array), acceptance (array)\r\n   333\t\r\n   334\tDOCUMENT CONTENT:\r\n   335\t${fileContent}`;\r\n   336\t\r\n   337\t  // Execute Gemini CLI\r\n   338\t  const result = Bash(`ccw cli -p '${cliPrompt.replace(/'/g, \"'\\\\''\")}' --tool gemini --mode analysis`, { timeout: 120000 });\r\n   339\t\r\n   340\t  // Parse JSON from result (may be wrapped in markdown code block)\r\n   341\t  let jsonText = result.trim();\r\n   342\t  const jsonMatch = jsonText.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\r\n   343\t  if (jsonMatch) {\r\n   344\t    jsonText = jsonMatch[1].trim();\r\n   345\t  }\r\n...\n\nPath: ccw\\docs-site\\docs\\commands\\issue\\issue-convert-to-plan.md\n     1\t---\r\n     2\ttitle: issue:convert-to-plan\r\n     3\tsidebar_label: issue:convert-to-plan\r\n     4\tsidebar_position: 7\r\n     5\tdescription: Convert planning artifacts to issue solutions\r\n     6\t---\r\n     7\t\r\n     8\t# issue:convert-to-plan\r\n     9\t\r\n    10\tConverts various planning artifact formats (lite-plan, workflow session, markdown, JSON) into issue workflow solutions with intelligent detection and automatic binding.\r\n    11\t\r\n    12\t## Description\r\n    13\t\r\n    14\tThe `issue:convert-to-plan` command bridges external planning workflows with the issue system. It auto-detects source formats, extracts task structures, normalizes to solution schema, and either creates new issues or supplements existing solutions.\r\n    15\t\r\n    16\t### Key Features\r\n    17\t\r\n    18\t- **Multi-format support**: lite-plan, workflow sessions, markdown, JSON\r\n    19\t- **Auto-detection**: Identifies source type automatically\r\n    20\t- **AI-assisted extraction**: Gemini CLI for markdown parsing\r\n    21\t- **Supplement mode**: Add tasks to existing solutions\r\n    22\t- **Auto-binding**: Solutions automatically bound to issues\r\n    23\t- **Issue auto-creation**: Creates issues from plans when needed\r\n    24\t\r\n    25\t## Usage\r\n    26\t\r\n    27\t```bash\r\n    28\t# Convert lite-plan to new issue (auto-creates issue)\r\n    29\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth-2026-01-25\"\r\n    30\t\r\n    31\t# Convert workflow session to existing issue\r\n    32\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    33\t\r\n    34\t# Convert markdown file to issue\r\n    35\t/issue:convert-to-plan \"./docs/implementation-plan.md\"\r\n    36\t\r\n    37\t# Supplement existing solution with additional tasks\r\n    38\t/issue:convert-to-plan \"./docs/additional-tasks.md\" --issue ISS-001 --supplement\r\n    39\t\r\n    40\t# Auto mode - skip confirmations\r\n    41\t/issue:convert-to-plan \".workflow/.lite-plan/my-plan\" -y\r\n    42\t```\r\n    43\t\r\n    44\t### Arguments\r\n    45\t\r\n    46\t| Argument | Required | Description |\r\n    47\t|----------|----------|-------------|\r\n    48\t| `SOURCE` | Yes | Planning artifact path or WFS-xxx ID |\r\n    49\t| `--issue &lt;id&gt;` | No | Bind to existing issue instead of creating new |\r\n    50\t| `--supplement` | No | Add tasks to existing solution (requires --issue) |\r\n    51\t| `-y, --yes` | No | Skip all confirmations |\r\n    52\t\r\n    53\t## Examples\r\n    54\t\r\n    55\t### Convert Lite-Plan\r\n    56\t\r\n    57\t```bash\r\n    58\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth\"\r\n    59\t# Output:\r\n    60\t# Detected source type: lite-plan\r\n    61\t# Extracted: 5 tasks\r\n    62\t# Created issue: ISS-20250129-001 (priority: 3)\r\n    63\t# ‚úì Created solution: SOL-ISS-20250129-001-a7b3\r\n    64\t# ‚úì Bound solution to issue\r\n    65\t# ‚Üí Status: planned\r\n    66\t```\r\n    67\t\r\n    68\t### Convert Workflow Session\r\n    69\t\r\n    70\t```bash\r\n    71\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    72\t# Output:\r\n    73\t# Detected source type: workflow-session\r\n    74\t# Loading session: .workflow/active/WFS-auth-impl/\r\n    75\t# Extracted: 8 tasks from session\r\n    76\t# ‚úì Created solution: SOL-GH-123-c9d2\r\n    77\t# ‚úì Bound solution to issue GH-123\r\n    78\t```\r\n    79\t\r\n    80\t### Convert Markdown with AI\r\n    81\t\r\n    82\t```bash\r\n    83\t/issue:convert-to-plan \"./docs/api-redesign.md\"\r\n    84\t# Output:\r\n    85\t# Detected source type: markdown-file\r\n    86\t# Using Gemini CLI for intelligent extraction...\r\n    87\t# Extracted: 6 tasks\r\n    88\t# Created issue: ISS-20250129-002 (priority: 2)\r\n    89\t# ‚úì Created solution: SOL-ISS-20250129-002-e4f1\r\n    90\t```\r\n    91\t\r\n    92\t### Supplement Existing Solution\r\n    93\t\r\n    94\t```bash\r\n    95\t/issue:convert-to-plan \"./docs/tasks-phase2.md\" --issue ISS-001 --supplement\r\n    96\t# Output:\r\n    97\t# Loaded existing solution: SOL-ISS-001-a7b3 (3 tasks)\r\n    98\t# Extracted: 2 new tasks\r\n    99\t# Supplementing: 3 existing + 2 new = 5 total tasks\r\n   100\t# ‚úì Updated solution: SOL-ISS-001-a7b3\r\n   101\t```\r\n   102\t\r\n   103\t## Issue Lifecycle Flow\r\n   104\t\r\n   105\t```mermaid\r\n   106\tgraph TB\r\n   107\t    A[Source Artifact] --> B{Detect Type}\r\n   108\t    B -->|Lite-Plan| C1[plan.json]\r\n   109\t    B -->|Workflow Session| C2[workflow-session.json]\r\n   110\t    B -->|Markdown| C3[.md File + Gemini AI]\r\n   111\t    B -->|JSON| C4[plan.json]\r\n   112\t    C1 --> D[Extract Tasks]\r\n   113\t    C2 --> D\r\n   114\t    C3 --> D\r\n   115\t    C4 --> D\r\n   116\t    D --> E{--issue\r\n   117\tProvided?}\r\n   118\t    E -->|Yes| F{Issue\r\n   119\tExists?}\r\n   120\t    E -->|No| G[Create New\r\n   121\tIssue]\r\n   122\t    F -->|Yes| H{--supplement?}\r\n   123\t    F -->|No| I[Error: Issue\r\n   124\tNot Found]\r\n   125\t    H -->|Yes| J[Load Existing\r\n   126\tSolution]\r\n   127\t    H -->|No| K[Create New\r\n   128\tSolution]\r\n   129\t    G --> K\r\n   130\t    J --> L[Merge Tasks]\r\n   131\t    K --> M[Normalize IDs]\r\n   132\t    L --> M\r\n   133\t    M --> N[Persist\r\n   134\tSolution]\r\n   135\t    N --> O[Bind to Issue]\r\n   136\t    O --> P[Status: Planned]\r\n   137\t    P --> Q[issue:queue]\r\n   138\t```\r\n   139\t\r\n   140\t## Supported Sources\r\n   141\t\r\n   142\t### 1. Lite-Plan\r\n   143\t\r\n   144\t**Location**: `.workflow/.lite-plan/&#123;slug&#125;/plan.json`\r\n   145\t\r\n   146\t**Schema**:\r\n   147\t```typescript\r\n   148\tinterface LitePlan {\r\n   149\t  summary: string;\r\n   150\t  approach: string;\r\n   151\t  complexity: 'low' | 'medium' | 'high';\r\n   152\t  estimated_time: string;\r\n   153\t  tasks: LiteTask[];\r\n   154\t  _metadata: {\r\n   155\t    timestamp: string;\r\n   156\t    exploration_angles: string[];\r\n   157\t  };\r\n   158\t}\r\n   159\t\r\n   160\tinterface LiteTask {\r\n   161\t  id: string;\r\n   162\t  title: string;\r\n   163\t  scope: string;\r\n   164\t  action: string;\r\n   165\t  description: string;\r\n   166\t  modification_points: Array<{file, target, change}>;\r\n   167\t  implementation: string[];\r\n   168\t  acceptance: string[];\r\n   169\t  depends_on: string[];\r\n   170\t}\r\n...\n   377\t\r\n   378\t- **[issue:plan](./issue-plan.md)** - Generate solutions from issue exploration\r\n   379\t- **[issue:new](./issue-new.md)** - Create issues from GitHub or text\r\n   380\t- **[issue:queue](./issue-queue.md)** - Form execution queue from converted plans\r\n   381\t- **[issue:execute](./issue-execute.md)** - Execute converted solutions\r\n   382\t- **[workflow:lite-lite-lite](#)** - Generate lite-plan artifacts\r\n   383\t- **[workflow:execute](#)** - Generate workflow sessions\r\n   384\t\r\n   385\t## Best Practices\r\n...\n\nPath: ccw\\src\\commands\\issue.ts#chunk4of4\n...\n   668\t      await queueAction(argsArray[0], argsArray[1], options);\r\n   669\t      break;\r\n   670\t    case 'next':\r\n   671\t      await nextAction(argsArray[0], options);\r\n   672\t      break;\r\n   673\t    case 'detail':\r\n   674\t      await detailAction(argsArray[0], options);\r\n   675\t      break;\r\n   676\t    case 'done':\r\n   677\t      await doneAction(argsArray[0], options);\r\n   678\t      break;\r\n   679\t    case 'retry':\r\n   680\t      await retryAction(argsArray[0], options);\r\n   681\t      break;\r\n   682\t    // Legacy aliases\r\n   683\t    case 'register':\r\n   684\t      console.log(chalk.yellow('Deprecated: use \"ccw issue bind <issue-id> --solution <path>\"'));\r\n   685\t      await bindAction(argsArray[0], undefined, options);\r\n   686\t      break;\r\n   687\t    case 'complete':\r\n   688\t      await doneAction(argsArray[0], options);\r\n   689\t      break;\r\n   690\t    case 'fail':\r\n   691\t      await doneAction(argsArray[0], { ...options, fail: true });\r\n   692\t      break;\r\n   693\t    default:\r\n   694\t      console.log(chalk.bold.cyan('\\nCCW Issue Management (v3.0 - Multi-Queue + Lifecycle)\\n'));\r\n...\n\nPath: .codex\\skills\\codex-issue-plan-execute\\specs\\solution-schema.md\n...\n    17\t\r\n    18\t```json\r\n    19\t{\r\n    20\t  \"id\": \"SOL-ISS-001-1\",\r\n    21\t  \"issue_id\": \"ISS-001\",\r\n    22\t  \"description\": \"Fix authentication token expiration by extending TTL\",\r\n    23\t  \"strategy_type\": \"bugfix\",\r\n    24\t  \"created_at\": \"2025-01-29T11:00:00Z\",\r\n    25\t  \"tasks\": [\r\n    26\t    {\r\n    27\t      \"id\": \"T1\",\r\n    28\t      \"title\": \"Update token TTL configuration\",\r\n    29\t      \"action\": \"Modify\",\r\n    30\t      \"scope\": \"src/config/auth.ts\",\r\n    31\t      \"description\": \"Increase JWT token expiration from 1h to 24h\",\r\n    32\t      \"modification_points\": [\r\n    33\t        {\r\n    34\t          \"file\": \"src/config/auth.ts\",\r\n    35\t          \"target\": \"JWT_EXPIRY\",\r\n    36\t          \"change\": \"Change value from 3600 to 86400\"\r\n    37\t        }\r\n    38\t      ],\r\n    39\t      \"implementation\": [\r\n    40\t        \"Open src/config/auth.ts\",\r\n    41\t        \"Locate JWT_EXPIRY constant\",\r\n    42\t        \"Update value: 3600 ‚Üí 86400\",\r\n    43\t        \"Add comment explaining change\"\r\n    44\t      ],\r\n...\n    83\t```\r\n    84\t\r\n    85\t## Â≠óÊÆµËØ¥Êòé\r\n    86\t\r\n    87\t### Âü∫Á°ÄÂ≠óÊÆµ\r\n    88\t\r\n    89\t| Â≠óÊÆµ | Á±ªÂûã | ÂøÖÈúÄ | ËØ¥Êòé |\r\n    90\t|------|------|------|------|\r\n    91\t| `id` | string | ‚úì | ÂîØ‰∏Ä IDÔºöSOL-{issue-id}-{seq} |\r\n    92\t| `issue_id` | string | ‚úì | ÂÖ≥ËÅîÁöÑ Issue ID |\r\n    93\t| `description` | string | ‚úì | Ëß£ÂÜ≥ÊñπÊ°àÊèèËø∞ |\r\n    94\t| `strategy_type` | string | | Á≠ñÁï•Á±ªÂûãÔºöbugfix/feature/refactor |\r\n    95\t| `tasks` | array | ‚úì | ‰ªªÂä°ÂàóË°®ÔºåËá≥Â∞ë 1 ‰∏™ |\r\n    96\t\r\n    97\t### Task Â≠óÊÆµ\r\n    98\t\r\n    99\t| Â≠óÊÆµ | Á±ªÂûã | ËØ¥Êòé |\r\n   100\t|------|------|------|\r\n   101\t| `id` | string | ‰ªªÂä° IDÔºöT1, T2, ... |\r\n   102\t| `title` | string | ‰ªªÂä°Ê†áÈ¢ò |\r\n   103\t| `action` | string | Âä®‰ΩúÁ±ªÂûãÔºöCreate/Modify/Fix/Refactor |\r\n   104\t| `scope` | string | ‰ΩúÁî®ËåÉÂõ¥ÔºöÊñá‰ª∂ÊàñÁõÆÂΩï |\r\n   105\t| `modification_points` | array | ÂÖ∑‰Ωì‰øÆÊîπÁÇπÂàóË°® |\r\n   106\t| `implementation` | array | ÂÆûÁé∞Ê≠•È™§ |\r\n   107\t| `test` | object | ÊµãËØïÂëΩ‰ª§ÂíåÁî®‰æã |\r\n   108\t| `acceptance` | object | È™åÊî∂Êù°‰ª∂ÂíåÈ™åËØÅÊ≠•È™§ |\r\n   109\t| `depends_on` | array | ‰ªªÂä°‰æùËµñÔºö[T1, T2] |\r\n   110\t| `estimated_minutes` | number | È¢ÑËÆ°ËÄóÊó∂ÔºàÂàÜÈíüÔºâ |\r\n   111\t\r\n   112\t### È™åÊî∂Êù°‰ª∂\r\n...\n\nPath: ccw\\src\\core\\routes\\issue-routes.ts#chunk1of2\n...\n   352\t\r\n   353\t  const normalizedPath = normalizeQueuePath(pathname);\r\n   354\t\r\n   355\t  // ===== Queue Routes (supports both /api/queue/* and /api/issues/queue/*) =====\r\n   356\t\r\n   357\t  // GET /api/queue or /api/issues/queue - Get execution queue\r\n   358\t  if ((normalizedPath === '/api/queue') && req.method === 'GET') {\r\n   359\t    const queue = groupQueueByExecutionGroup(readQueue(issuesDir));\r\n   360\t    res.writeHead(200, { 'Content-Type': 'application/json' });\r\n   361\t    res.end(JSON.stringify(queue));\r\n   362\t    return true;\r\n   363\t  }\r\n...\n   390\t\r\n   391\t  // GET /api/queue/:id or /api/issues/queue/:id - Get specific queue by ID\r\n   392\t  const queueDetailMatch = normalizedPath?.match(/^\\/api\\/queue\\/([^/]+)$/);\r\n   393\t  const reservedQueuePaths = ['history', 'reorder', 'switch', 'deactivate', 'merge', 'activate'];\r\n   394\t  if (queueDetailMatch && req.method === 'GET' && !reservedQueuePaths.includes(queueDetailMatch[1])) {\r\n   395\t    const queueId = queueDetailMatch[1];\r\n   396\t    const queuesDir = join(issuesDir, 'queues');\r\n   397\t    const queueFilePath = join(queuesDir, `${queueId}.json`);\r\n   398\t\r\n   399\t    if (!existsSync(queueFilePath)) {\r\n   400\t      res.writeHead(404, { 'Content-Type': 'application/json' });\r\n   401\t      res.end(JSON.stringify({ error: `Queue ${queueId} not found` }));\r\n   402\t      return true;\r\n   403\t    }\r\n...\n\nPath: ccw\\src\\core\\routes\\commands-routes.ts\n...\n   287\t\r\n   288\t  const groupSet = new Set<string>();\r\n   289\t\r\n   290\t  try {\r\n   291\t    // Scan project commands (includes both .md and .md.disabled)\r\n   292\t    const projectDir = getCommandsDir('project', projectPath);\r\n   293\t    result.projectCommands = scanCommandsRecursive(projectDir, projectDir, 'project', projectPath);\r\n   294\t\r\n   295\t    // Scan user commands (includes both .md and .md.disabled)\r\n   296\t    const userDir = getCommandsDir('user', projectPath);\r\n   297\t    result.userCommands = scanCommandsRecursive(userDir, userDir, 'user', projectPath);\r\n   298\t\r\n   299\t    // Collect all groups\r\n   300\t    for (const cmd of [...result.projectCommands, ...result.userCommands]) {\r\n   301\t      groupSet.add(cmd.group);\r\n   302\t    }\r\n   303\t\r\n   304\t    result.groups = Array.from(groupSet).sort();\r\n   305\t  } catch (error) {\r\n   306\t    console.error('[Commands] Error reading commands config:', error);\r\n   307\t  }\r\n   308\t\r\n   309\t  return result;\r\n   310\t}\r\n...\n\nPath: .claude\\workflows\\cli-templates\\schemas\\solution-schema.json\n     1\t{\r\n     2\t  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n     3\t  \"title\": \"Issue Solution Schema\",\r\n     4\t  \"description\": \"Schema for solution registered to an issue\",\r\n     5\t  \"type\": \"object\",\r\n     6\t  \"required\": [\"id\", \"tasks\", \"is_bound\", \"created_at\"],\r\n     7\t  \"properties\": {\r\n     8\t    \"id\": {\r\n     9\t      \"type\": \"string\",\r\n    10\t      \"description\": \"Unique solution identifier: SOL-{issue-id}-{4-char-uid} where uid is 4 alphanumeric chars\",\r\n    11\t      \"pattern\": \"^SOL-.+-[a-z0-9]{4}$\",\r\n    12\t      \"examples\": [\"SOL-GH-123-a7x9\", \"SOL-ISS-20251229-001-b2k4\"]\r\n    13\t    },\r\n    14\t    \"description\": {\r\n    15\t      \"type\": \"string\",\r\n    16\t      \"description\": \"High-level summary of the solution\"\r\n    17\t    },\r\n    18\t    \"approach\": {\r\n    19\t      \"type\": \"string\",\r\n    20\t      \"description\": \"Technical approach or strategy\"\r\n    21\t    },\r\n...\n\n",
      "type": "text"
    }
  ]
}
tool ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Find TypeScript implementation for CCW CLI issue commands referenced by /issue:convert-to-plan. Keywords: \"issue status\" \"issue init\" \"issue bind\" \"issue solutions\" in ccw/src. Also locate any handler for convert-to-plan."})
ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Find TypeScript implementation for CCW CLI issue commands referenced by /issue:convert-to-plan. Keywords: \"issue status\" \"issue init\" \"issue bind\" \"issue solutions\" in ccw/src. Also locate any handler for convert-to-plan."}) success in 5.84s:
{
  "content": [
    {
      "text": "The following code sections were retrieved:\nPath: .claude\\commands\\issue\\convert-to-plan.md\n     1\t---\r\n     2\tname: convert-to-plan\r\n     3\tdescription: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions\r\n     4\targument-hint: \"[-y|--yes] [--issue <id>] [--supplement] <SOURCE>\"\r\n     5\tallowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)\r\n     6\t---\r\n     7\t\r\n     8\t## Auto Mode\r\n     9\t\r\n    10\tWhen `--yes` or `-y`: Skip confirmation, auto-create issue and bind solution.\r\n    11\t\r\n    12\t# Issue Convert-to-Plan Command (/issue:convert-to-plan)\r\n    13\t\r\n    14\t## Overview\r\n    15\t\r\n    16\tConverts various planning artifact formats into issue workflow solutions with intelligent detection and automatic binding.\r\n    17\t\r\n    18\t**Supported Sources** (auto-detected):\r\n    19\t- **lite-plan**: `.workflow/.lite-plan/{slug}/plan.json`\r\n    20\t- **workflow-session**: `WFS-xxx` ID or `.workflow/active/{session}/` folder\r\n    21\t- **markdown**: Any `.md` file with implementation/task content\r\n    22\t- **json**: Direct JSON files matching plan-json-schema\r\n    23\t\r\n    24\t## Quick Reference\r\n    25\t\r\n    26\t```bash\r\n    27\t# Convert lite-plan to new issue (auto-creates issue)\r\n    28\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth-2026-01-25\"\r\n    29\t\r\n    30\t# Convert workflow session to existing issue\r\n    31\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    32\t\r\n    33\t# Supplement existing solution with additional tasks\r\n    34\t/issue:convert-to-plan \"./docs/additional-tasks.md\" --issue ISS-001 --supplement\r\n...\n    52\t\r\n    53\t| Operation | Correct | Incorrect |\r\n    54\t|-----------|---------|-----------|\r\n    55\t| Get issue | `ccw issue status <id> --json` | Read issues.jsonl directly |\r\n    56\t| Create issue | `ccw issue init <id> --title \"...\"` | Write to issues.jsonl |\r\n    57\t| Bind solution | `ccw issue bind <id> <sol-id>` | Edit issues.jsonl |\r\n    58\t| List solutions | `ccw issue solutions --issue <id> --brief` | Read solutions/*.jsonl |\r\n    59\t\r\n    60\t## Solution Schema Reference\r\n    61\t\r\n    62\tTarget format for all extracted data (from solution-schema.json):\r\n...\n    92\t\r\n    93\ttype Action = 'Create' | 'Update' | 'Implement' | 'Refactor' | 'Add' | 'Delete' | 'Configure' | 'Test' | 'Fix';\r\n    94\t```\r\n    95\t\r\n    96\t## Implementation\r\n    97\t\r\n    98\t### Phase 1: Parse Arguments & Detect Source Type\r\n    99\t\r\n   100\t```javascript\r\n   101\tconst input = userInput.trim();\r\n   102\tconst flags = parseFlags(userInput);  // --issue, --supplement, -y/--yes\r\n   103\t\r\n   104\t// Extract source path (first non-flag argument)\r\n   105\tconst source = extractSourceArg(input);\r\n   106\t\r\n   107\t// Detect source type\r\n   108\tfunction detectSourceType(source) {\r\n   109\t  // Check for WFS-xxx pattern (workflow session ID)\r\n   110\t  if (source.match(/^WFS-[\\w-]+$/)) {\r\n   111\t    return { type: 'workflow-session-id', path: `.workflow/active/${source}` };\r\n   112\t  }\r\n...\n   249\t\r\n   250\t  // Load all task JSONs from .task folder\r\n   251\t  const taskFiles = Glob({ pattern: `${sessionPath}/.task/IMPL-*.json` });\r\n   252\t  const tasks = taskFiles.map(f => {\r\n   253\t    const taskJson = Read(f);\r\n   254\t    const task = JSON.parse(taskJson);\r\n   255\t    return {\r\n   256\t      id: task.id?.replace(/^IMPL-0*/, 'T') || 'T1',  // IMPL-001 ‚Üí T1\r\n   257\t      title: task.title,\r\n   258\t      scope: task.scope || inferScopeFromTask(task),\r\n   259\t      action: capitalizeAction(task.type) || 'Implement',\r\n   260\t      description: task.description,\r\n   261\t      modification_points: task.implementation?.modification_points || [],\r\n   262\t      implementation: task.implementation?.steps || [],\r\n   263\t      test: task.implementation?.test || {},\r\n   264\t      acceptance: {\r\n   265\t        criteria: task.acceptance_criteria || [],\r\n   266\t        verification: task.verification_steps || []\r\n   267\t      },\r\n...\n   327\t      \"implementation\": [\"step 1\", \"step 2\"],\r\n   328\t      \"acceptance\": [\"criteria 1\", \"criteria 2\"]\r\n   329\t    }\r\n   330\t  ]\r\n   331\t}\r\n   332\tCONSTRAINTS: Output ONLY valid JSON - no markdown, no explanation | Action must be one of: Create, Update, Implement, Refactor, Add, Delete, Configure, Test, Fix | Tasks must have id, title, scope, action, implementation (array), acceptance (array)\r\n   333\t\r\n   334\tDOCUMENT CONTENT:\r\n   335\t${fileContent}`;\r\n   336\t\r\n   337\t  // Execute Gemini CLI\r\n   338\t  const result = Bash(`ccw cli -p '${cliPrompt.replace(/'/g, \"'\\\\''\")}' --tool gemini --mode analysis`, { timeout: 120000 });\r\n   339\t\r\n   340\t  // Parse JSON from result (may be wrapped in markdown code block)\r\n   341\t  let jsonText = result.trim();\r\n   342\t  const jsonMatch = jsonText.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\r\n   343\t  if (jsonMatch) {\r\n   344\t    jsonText = jsonMatch[1].trim();\r\n   345\t  }\r\n...\n   399\t\r\n   400\t  // Detect if it's already solution format or plan format\r\n   401\t  if (plan.tasks && Array.isArray(plan.tasks)) {\r\n   402\t    // Map tasks to normalized format\r\n   403\t    const tasks = plan.tasks.map((t, i) => ({\r\n   404\t      id: t.id || `T${i + 1}`,\r\n   405\t      title: t.title,\r\n   406\t      scope: t.scope || '',\r\n   407\t      action: t.action || 'Implement',\r\n   408\t      description: t.description || t.title,\r\n   409\t      modification_points: t.modification_points || [],\r\n   410\t      implementation: Array.isArray(t.implementation) ? t.implementation : [t.implementation || ''],\r\n   411\t      test: t.test || t.verification || {},\r\n   412\t      acceptance: normalizeAcceptance(t.acceptance),\r\n   413\t      depends_on: t.depends_on || [],\r\n   414\t      priority: t.priority || 3\r\n   415\t    }));\r\n...\n   464\t\r\n   465\tif (issueId) {\r\n   466\t  // Validate issue exists\r\n   467\t  let issueCheck;\r\n   468\t  try {\r\n   469\t    issueCheck = Bash(`ccw issue status ${issueId} --json 2>/dev/null`).trim();\r\n   470\t    if (!issueCheck || issueCheck === '') {\r\n   471\t      throw new Error('empty response');\r\n   472\t    }\r\n   473\t  } catch (e) {\r\n   474\t    throw new Error(`E003: Issue not found: ${issueId}`);\r\n   475\t  }\r\n   476\t\r\n   477\t  const issue = JSON.parse(issueCheck);\r\n   478\t\r\n   479\t  // Check if issue already has bound solution\r\n   480\t  if (issue.bound_solution_id && !flags.supplement) {\r\n   481\t    throw new Error(`E004: Issue ${issueId} already has bound solution (${issue.bound_solution_id}). Use --supplement to add tasks.`);\r\n   482\t  }\r\n...\n   494\t} else {\r\n   495\t  // Create new issue via ccw issue create (auto-generates correct ID)\r\n   496\t  // Smart extraction: title from content, priority from complexity\r\n   497\t  const title = extracted.title || 'Converted Plan';\r\n   498\t  const context = extracted.description || extracted.approach || title;\r\n   499\t\r\n   500\t  // Auto-determine priority based on complexity\r\n   501\t  const complexityMap = { high: 2, medium: 3, low: 4 };\r\n   502\t  const priority = complexityMap[extracted.metadata.complexity?.toLowerCase()] || 3;\r\n   503\t\r\n   504\t  try {\r\n   505\t    // Use heredoc to avoid shell escaping issues\r\n   506\t    const createResult = Bash(`ccw issue create << 'EOF'\r\n   507\t{\r\n   508\t  \"title\": ${JSON.stringify(title)},\r\n   509\t  \"context\": ${JSON.stringify(context)},\r\n   510\t  \"priority\": ${priority},\r\n   511\t  \"source\": \"converted\"\r\n   512\t}\r\n...\n   599\t\r\n   600\t// Confirm if not auto mode\r\n   601\tif (!flags.yes && !flags.y) {\r\n   602\t  const confirm = AskUserQuestion({\r\n   603\t    questions: [{\r\n   604\t      question: `Create solution for issue ${issueId} with ${solution.tasks.length} tasks?`,\r\n   605\t      header: 'Confirm',\r\n   606\t      multiSelect: false,\r\n   607\t      options: [\r\n   608\t        { label: 'Yes, create solution', description: 'Create and bind solution' },\r\n   609\t        { label: 'Cancel', description: 'Abort without changes' }\r\n   610\t      ]\r\n   611\t    }]\r\n   612\t  });\r\n   613\t\r\n   614\t  if (!confirm.answers?.['Confirm']?.includes('Yes')) {\r\n   615\t    console.log('Cancelled.');\r\n   616\t    return;\r\n   617\t  }\r\n   618\t}\r\n   619\t\r\n   620\t// Persist solution (following issue-plan-agent pattern)\r\n   621\tBash(`mkdir -p .workflow/issues/solutions`);\r\n   622\t\r\n   623\tconst solutionFile = `.workflow/issues/solutions/${issueId}.jsonl`;\r\n...\n   659\t\r\n   660\t  // Bind solution to issue\r\n   661\t  try {\r\n   662\t    Bash(`ccw issue bind ${issueId} ${solutionId}`);\r\n   663\t    console.log(`‚úì Bound solution to issue`);\r\n   664\t  } catch (e) {\r\n   665\t    // Cleanup: remove solution file on bind failure\r\n   666\t    try {\r\n   667\t      Bash(`rm -f \"${solutionFile}\"`);\r\n   668\t    } catch (cleanupError) {\r\n   669\t      // Ignore cleanup errors\r\n   670\t    }\r\n   671\t    throw new Error(`Failed to bind solution: ${e.message}`);\r\n   672\t  }\r\n   673\t\r\n   674\t  // Update issue status to planned\r\n   675\t  try {\r\n   676\t    Bash(`ccw issue update ${issueId} --status planned`);\r\n   677\t  } catch (e) {\r\n   678\t    throw new Error(`Failed to update issue status: ${e.message}`);\r\n   679\t  }\r\n   680\t}\r\n...\n\nPath: ccw\\docs-site\\docs\\commands\\issue\\issue-convert-to-plan.md\n     1\t---\r\n     2\ttitle: issue:convert-to-plan\r\n     3\tsidebar_label: issue:convert-to-plan\r\n     4\tsidebar_position: 7\r\n     5\tdescription: Convert planning artifacts to issue solutions\r\n     6\t---\r\n     7\t\r\n     8\t# issue:convert-to-plan\r\n     9\t\r\n    10\tConverts various planning artifact formats (lite-plan, workflow session, markdown, JSON) into issue workflow solutions with intelligent detection and automatic binding.\r\n    11\t\r\n    12\t## Description\r\n    13\t\r\n    14\tThe `issue:convert-to-plan` command bridges external planning workflows with the issue system. It auto-detects source formats, extracts task structures, normalizes to solution schema, and either creates new issues or supplements existing solutions.\r\n    15\t\r\n    16\t### Key Features\r\n...\n    56\t\r\n    57\t```bash\r\n    58\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth\"\r\n    59\t# Output:\r\n    60\t# Detected source type: lite-plan\r\n    61\t# Extracted: 5 tasks\r\n    62\t# Created issue: ISS-20250129-001 (priority: 3)\r\n    63\t# ‚úì Created solution: SOL-ISS-20250129-001-a7b3\r\n    64\t# ‚úì Bound solution to issue\r\n    65\t# ‚Üí Status: planned\r\n    66\t```\r\n    67\t\r\n    68\t### Convert Workflow Session\r\n    69\t\r\n    70\t```bash\r\n    71\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    72\t# Output:\r\n    73\t# Detected source type: workflow-session\r\n    74\t# Loading session: .workflow/active/WFS-auth-impl/\r\n    75\t# Extracted: 8 tasks from session\r\n    76\t# ‚úì Created solution: SOL-GH-123-c9d2\r\n    77\t# ‚úì Bound solution to issue GH-123\r\n    78\t```\r\n    79\t\r\n    80\t### Convert Markdown with AI\r\n...\n   354\t\r\n   355\t## CLI Endpoints\r\n   356\t\r\n   357\t```bash\r\n   358\t# Create new issue\r\n   359\tccw issue create << 'EOF'\r\n   360\t{\"title\":\"...\",\"context\":\"...\",\"priority\":3,\"source\":\"converted\"}\r\n   361\tEOF\r\n   362\t\r\n   363\t# Check issue exists\r\n   364\tccw issue status &lt;id&gt; --json\r\n   365\t\r\n   366\t# Get existing solution\r\n   367\tccw issue solution &lt;solution-id&gt; --json\r\n   368\t\r\n   369\t# Bind solution to issue\r\n   370\tccw issue bind &lt;issue-id&gt; &lt;solution-id&gt;\r\n   371\t\r\n   372\t# Update issue status\r\n   373\tccw issue update &lt;issue-id&gt; --status planned\r\n   374\t```\r\n   375\t\r\n   376\t## Related Commands\r\n...\n\nPath: status-reference.md\n...\n   130\t\r\n   131\t# ÊåâÁä∂ÊÄÅÁ≠õÈÄâ Issue\r\n   132\tccw issue list --status planned,queued\r\n   133\t\r\n   134\t# Êü•ÁúãÈòüÂàóÁä∂ÊÄÅ\r\n   135\tccw issue queue\r\n   136\t\r\n   137\t# Êü•ÁúãÈòüÂàó DAGÔºàÂê´ ready/blocked ËÆ°ÁÆóÁä∂ÊÄÅÔºâ\r\n   138\tccw issue queue dag\r\n   139\t```\r\n   140\t\r\n   141\t### Áä∂ÊÄÅÊõ¥Êñ∞\r\n   142\t\r\n   143\t```bash\r\n   144\t# Êõ¥Êñ∞ Issue Áä∂ÊÄÅ\r\n   145\tccw issue update <issue-id> --status <status>\r\n   146\t\r\n   147\t# ‰ªéÈòüÂàóÂêåÊ≠• Issue Áä∂ÊÄÅ‰∏∫ queued\r\n   148\tccw issue update --from-queue\r\n   149\t\r\n   150\t# ÈáçËØïÂ§±Ë¥•È°πÔºàQueueItem ‚Üí pending, Issue ‚Üí queued, Queue ‚Üí activeÔºâ\r\n   151\tccw issue retry [issue-id]\r\n   152\t```\r\n   153\t\r\n   154\t### ÊâßË°åÊµÅÁ®ã\r\n   155\t\r\n   156\t```bash\r\n   157\t# Ê∑ªÂä†Âà∞ÈòüÂàó (Issue ‚Üí queued, ÂàõÂª∫ QueueItem ‚Üí pending)\r\n   158\tccw issue queue add <issue-id>\r\n   159\t\r\n   160\t# Ëé∑Âèñ‰∏ã‰∏Ä‰∏™ÊâßË°åÈ°π (QueueItem ‚Üí executing, Issue ‚Üí executing)\r\n   161\tccw issue next\r\n   162\t\r\n   163\t# Ê†áËÆ∞ÂÆåÊàê (QueueItem ‚Üí completed, Issue ‚Üí completed)\r\n   164\tccw issue done <item-id>\r\n   165\t\r\n   166\t# Ê†áËÆ∞Â§±Ë¥• (QueueItem ‚Üí failed, Issue ‚Üí failed)\r\n   167\tccw issue done <item-id> --fail --reason \"error message\"\r\n   168\t```\r\n   169\t\r\n   170\t---\r\n   171\t\r\n   172\t## Áä∂ÊÄÅÂØπÁÖßË°®\r\n...\n\nPath: ccw\\src\\commands\\issue.ts#chunk3of4\n     1\t  if (!issueId) {\r\n     2\t    // Show queue status\r\n     3\t    const queue = readActiveQueue();\r\n     4\t    const issues = readIssues();\r\n     5\t    const index = readQueueIndex();\r\n     6\t\r\n     7\t    if (options.json) {\r\n     8\t      // Return full queue for programmatic access\r\n     9\t      console.log(JSON.stringify(queue, null, 2));\r\n    10\t      return;\r\n    11\t    }\r\n    12\t\r\n    13\t    console.log(chalk.bold.cyan('\\nSystem Status\\n'));\r\n    14\t    console.log(`Issues: ${issues.length}`);\r\n    15\t    console.log(`Queues: ${index.queues.length} (Active: ${index.active_queue_id || 'none'})`);\r\n    16\t    console.log(`Active Queue: ${queue._metadata.total_tasks} tasks`);\r\n    17\t    console.log(`  Pending: ${queue._metadata.pending_count}`);\r\n    18\t    console.log(`  Executing: ${queue._metadata.executing_count}`);\r\n    19\t    console.log(`  Completed: ${queue._metadata.completed_count}`);\r\n    20\t    console.log(`  Failed: ${queue._metadata.failed_count}`);\r\n    21\t    return;\r\n    22\t  }\r\n...\n   284\t\r\n   285\t/**\r\n   286\t * bind - Register and/or bind a solution\r\n   287\t */\r\n   288\tasync function bindAction(issueId: string | undefined, solutionId: string | undefined, options: IssueOptions): Promise<void> {\r\n   289\t  if (!issueId) {\r\n   290\t    console.error(chalk.red('Issue ID is required'));\r\n   291\t    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));\r\n   292\t    process.exit(1);\r\n   293\t  }\r\n   294\t\r\n   295\t  const issue = findIssue(issueId);\r\n   296\t  if (!issue) {\r\n   297\t    console.error(chalk.red(`Issue \"${issueId}\" not found`));\r\n   298\t    process.exit(1);\r\n   299\t  }\r\n   300\t\r\n   301\t  let solutions = readSolutions(issueId);\r\n...\n   343\t\r\n   344\t  // Bind the specified solution\r\n   345\t  const solIdx = solutions.findIndex(s => s.id === solutionId);\r\n   346\t  if (solIdx === -1) {\r\n   347\t    console.error(chalk.red(`Solution \"${solutionId}\" not found`));\r\n   348\t    process.exit(1);\r\n   349\t  }\r\n   350\t\r\n   351\t  // Unbind all, bind selected\r\n   352\t  solutions = solutions.map(s => ({ ...s, is_bound: false }));\r\n   353\t  solutions[solIdx].is_bound = true;\r\n   354\t  solutions[solIdx].bound_at = new Date().toISOString();\r\n   355\t\r\n   356\t  writeSolutions(issueId, solutions);\r\n   357\t  updateIssue(issueId, {\r\n   358\t    bound_solution_id: solutionId,\r\n   359\t    status: 'planned',\r\n   360\t    planned_at: new Date().toISOString()\r\n   361\t  });\r\n   362\t\r\n   363\t  console.log(chalk.green(`‚úì Solution ${solutionId} bound to ${issueId}`));\r\n   364\t}\r\n...\n\nPath: .claude\\commands\\issue\\queue.md\n...\n    31\t\r\n    32\t| Operation | Correct | Incorrect |\r\n    33\t|-----------|---------|-----------|\r\n    34\t| List issues (brief) | `ccw issue list --status planned --brief` | `Read('issues.jsonl')` |\r\n    35\t| **Batch solutions (NEW)** | `ccw issue solutions --status planned --brief` | Loop `ccw issue solution <id>` |\r\n    36\t| List queue (brief) | `ccw issue queue --brief` | `Read('queues/*.json')` |\r\n    37\t| Read issue details | `ccw issue status <id> --json` | `Read('issues.jsonl')` |\r\n    38\t| Get next item | `ccw issue next --json` | `Read('queues/*.json')` |\r\n    39\t| Update status | `ccw issue update <id> --status ...` | Direct file edit |\r\n    40\t| Sync from queue | `ccw issue update --from-queue` | Direct file edit |\r\n    41\t| Read solution (single) | `ccw issue solution <id> --brief` | `Read('solutions/*.jsonl')` |\r\n...\n   294\t```\r\n   295\t\r\n   296\t### Phase 6: Status Update & Summary\r\n   297\t\r\n   298\t**Status Update** (MUST use CLI command, NOT direct file operations):\r\n   299\t\r\n   300\t```bash\r\n   301\t# Option 1: Batch update from queue (recommended)\r\n   302\tccw issue update --from-queue [queue-id] --json\r\n   303\tccw issue update --from-queue --json              # Use active queue\r\n   304\tccw issue update --from-queue QUE-xxx --json      # Use specific queue\r\n   305\t\r\n   306\t# Option 2: Individual issue update\r\n   307\tccw issue update <issue-id> --status queued\r\n   308\t```\r\n   309\t\r\n   310\t**‚ö†Ô∏è IMPORTANT**: Do NOT directly modify `issues.jsonl`. Always use CLI command to ensure proper validation and history tracking.\r\n   311\t\r\n   312\t**Output** (JSON):\r\n   313\t```json\r\n   314\t{\r\n   315\t  \"success\": true,\r\n   316\t  \"queue_id\": \"QUE-xxx\",\r\n   317\t  \"queued\": [\"ISS-001\", \"ISS-002\"],\r\n   318\t  \"queued_count\": 2,\r\n   319\t  \"unplanned\": [\"ISS-003\"],\r\n   320\t  \"unplanned_count\": 1\r\n   321\t}\r\n...\n\nPath: ccw\\src\\core\\routes\\issue-routes.ts#chunk1of2\n...\n   276\t\r\n   277\t/**\r\n   278\t * Bind solution to issue with proper side effects\r\n   279\t */\r\n   280\tfunction bindSolutionToIssue(issuesDir: string, issueId: string, solutionId: string, issues: any[], issueIndex: number) {\r\n   281\t  const solutions = readSolutionsJsonl(issuesDir, issueId);\r\n   282\t  const solIndex = solutions.findIndex(s => s.id === solutionId);\r\n   283\t\r\n   284\t  if (solIndex === -1) return { error: `Solution ${solutionId} not found` };\r\n   285\t\r\n   286\t  // Unbind all, bind new\r\n   287\t  solutions.forEach(s => { s.is_bound = false; });\r\n   288\t  solutions[solIndex].is_bound = true;\r\n   289\t  solutions[solIndex].bound_at = new Date().toISOString();\r\n   290\t  writeSolutionsJsonl(issuesDir, issueId, solutions);\r\n   291\t\r\n   292\t  // Update issue\r\n   293\t  issues[issueIndex].bound_solution_id = solutionId;\r\n   294\t  issues[issueIndex].status = 'planned';\r\n   295\t  issues[issueIndex].planned_at = new Date().toISOString();\r\n...\n\nPath: ccw\\src\\commands\\issue.ts#chunk4of4\n...\n   290\t\r\n   291\t  // Only update status if not already executing\r\n   292\t  if (!isResume) {\r\n   293\t    const idx = items.findIndex(q => q.item_id === nextItem.item_id);\r\n   294\t    items[idx].status = 'executing';\r\n   295\t    items[idx].started_at = new Date().toISOString();\r\n   296\t    // Write back to correct array\r\n   297\t    if (queue.solutions) {\r\n   298\t      queue.solutions = items;\r\n   299\t    } else {\r\n   300\t      queue.tasks = items;\r\n   301\t    }\r\n   302\t    writeQueue(queue);\r\n   303\t    updateIssue(nextItem.issue_id, { status: 'executing' });\r\n   304\t  }\r\n   305\t\r\n   306\t  // Calculate queue stats\r\n   307\t  const stats = {\r\n   308\t    total: items.length,\r\n   309\t    completed: items.filter(q => q.status === 'completed').length,\r\n   310\t    failed: items.filter(q => q.status === 'failed').length,\r\n   311\t    executing: items.filter(q => q.status === 'executing').length,\r\n   312\t    pending: items.filter(q => q.status === 'pending').length\r\n   313\t  };\r\n...\n\nPath: .claude\\commands\\issue\\from-brainstorm.md\n...\n   262\tEOF\r\n   263\t```\r\n   264\t\r\n   265\t### Solution Binding\r\n   266\t```bash\r\n   267\t# Append solution to JSONL file\r\n   268\techo '{\"id\":\"SOL-xxx\",\"tasks\":[...]}' >> .workflow/issues/solutions/{issue-id}.jsonl\r\n   269\t\r\n   270\t# Bind to issue\r\n   271\tccw issue bind {issue-id} {solution-id}\r\n   272\t\r\n   273\t# Update status\r\n   274\tccw issue update {issue-id} --status planned\r\n   275\t```\r\n   276\t\r\n   277\t## Error Handling\r\n   278\t\r\n   279\t| Error | Message | Resolution |\r\n   280\t|-------|---------|------------|\r\n   281\t| Session not found | synthesis.json missing | Check session ID, list available sessions |\r\n   282\t| No ideas | top_ideas array empty | Complete brainstorm workflow first |\r\n   283\t| Invalid idea index | Index out of range | Check valid range 0 to N-1 |\r\n   284\t| Issue creation failed | ccw issue create error | Verify CLI endpoint working |\r\n   285\t| Solution binding failed | Bind error | Check issue exists, retry |\r\n   286\t\r\n   287\t## Examples\r\n...\n\n",
      "type": "text"
    }
  ]
}

thinking
**Generating outlines for commands**

I think it‚Äôs fine to create outlines for the existing command documentation. I see it as a fresh task, even though it's based on existing materials. The outlines should accurately describe the command. Maybe I can draw some references from a similar command, like `/issue:from-brainstorm`, which shares functionality regarding brainstorming artifacts. I‚Äôll check if the `.claude/commands/issue/from-brainstorm.md` file exists, and then I can explore additional commands like `/issue:plan` or `/workflow:lite-plan`. I‚Äôll use smart search to find relevant conversions.
tool ccw-tools.smart_search({"action":"search","query":".workflow/.lite-plan","paths":[".claude/commands"],"mode":"fuzzy","maxResults":20})
2026-02-04T19:02:39.709466Z ERROR rmcp::transport::async_rw: Error reading from stream: serde error expected value at line 1 column 2
ccw-tools.smart_search({"action":"search","query":".workflow/.lite-plan","paths":[".claude/commands"],"mode":"fuzzy","maxResults":20}) failed in 3.04s:

thinking
**Troubleshooting search tools**

The Smart_search tool seems to be failing, likely due to a transport closure ‚Äî maybe the MCP server crashed? I should fall back to using the shell command `rg`, even though the instructions say to avoid it when MCP is available. I can use the ACE search_context for querying documents, especially looking for patterns like ".workflow/.lite-plan". If the tool continues to fail, I may have to rely on the shell. Let‚Äôs see what happens next!
tool ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Find similar slash commands to /issue:convert-to-plan for reference selection. Search .claude/commands for commands that generate/append/bind issue solutions from other artifacts: brainstorm, lite-plan, workflow session, markdown conversion. Keywords: \"solution binding\", \"ccw issue bind\", \"solution-schema.json\", \"lite-plan\", \"workflow session\", \"WFS-\"."})
ace-tool.search_context({"project_root_path":"C:/Project/Claude-Code-Workflow","query":"Find similar slash commands to /issue:convert-to-plan for reference selection. Search .claude/commands for commands that generate/append/bind issue solutions from other artifacts: brainstorm, lite-plan, workflow session, markdown conversion. Keywords: \"solution binding\", \"ccw issue bind\", \"solution-schema.json\", \"lite-plan\", \"workflow session\", \"WFS-\"."}) success in 5.50s:
{
  "content": [
    {
      "text": "The following code sections were retrieved:\nPath: .claude\\commands\\issue\\convert-to-plan.md\n     1\t---\r\n     2\tname: convert-to-plan\r\n     3\tdescription: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions\r\n     4\targument-hint: \"[-y|--yes] [--issue <id>] [--supplement] <SOURCE>\"\r\n     5\tallowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)\r\n     6\t---\r\n     7\t\r\n     8\t## Auto Mode\r\n     9\t\r\n    10\tWhen `--yes` or `-y`: Skip confirmation, auto-create issue and bind solution.\r\n    11\t\r\n    12\t# Issue Convert-to-Plan Command (/issue:convert-to-plan)\r\n    13\t\r\n    14\t## Overview\r\n    15\t\r\n    16\tConverts various planning artifact formats into issue workflow solutions with intelligent detection and automatic binding.\r\n    17\t\r\n    18\t**Supported Sources** (auto-detected):\r\n    19\t- **lite-plan**: `.workflow/.lite-plan/{slug}/plan.json`\r\n    20\t- **workflow-session**: `WFS-xxx` ID or `.workflow/active/{session}/` folder\r\n    21\t- **markdown**: Any `.md` file with implementation/task content\r\n    22\t- **json**: Direct JSON files matching plan-json-schema\r\n    23\t\r\n    24\t## Quick Reference\r\n    25\t\r\n    26\t```bash\r\n    27\t# Convert lite-plan to new issue (auto-creates issue)\r\n    28\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth-2026-01-25\"\r\n    29\t\r\n    30\t# Convert workflow session to existing issue\r\n    31\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    32\t\r\n    33\t# Supplement existing solution with additional tasks\r\n    34\t/issue:convert-to-plan \"./docs/additional-tasks.md\" --issue ISS-001 --supplement\r\n    35\t\r\n    36\t# Auto mode - skip confirmations\r\n    37\t/issue:convert-to-plan \".workflow/.lite-plan/my-plan\" -y\r\n    38\t```\r\n    39\t\r\n    40\t## Command Options\r\n    41\t\r\n    42\t| Option | Description | Default |\r\n    43\t|--------|-------------|---------|\r\n    44\t| `<SOURCE>` | Planning artifact path or WFS-xxx ID | Required |\r\n    45\t| `--issue <id>` | Bind to existing issue instead of creating new | Auto-create |\r\n    46\t| `--supplement` | Add tasks to existing solution (requires --issue) | false |\r\n    47\t| `-y, --yes` | Skip all confirmations | false |\r\n    48\t\r\n    49\t## Core Data Access Principle\r\n    50\t\r\n    51\t**‚ö†Ô∏è Important**: Use CLI commands for all issue/solution operations.\r\n    52\t\r\n    53\t| Operation | Correct | Incorrect |\r\n    54\t|-----------|---------|-----------|\r\n    55\t| Get issue | `ccw issue status <id> --json` | Read issues.jsonl directly |\r\n    56\t| Create issue | `ccw issue init <id> --title \"...\"` | Write to issues.jsonl |\r\n    57\t| Bind solution | `ccw issue bind <id> <sol-id>` | Edit issues.jsonl |\r\n    58\t| List solutions | `ccw issue solutions --issue <id> --brief` | Read solutions/*.jsonl |\r\n    59\t\r\n    60\t## Solution Schema Reference\r\n    61\t\r\n    62\tTarget format for all extracted data (from solution-schema.json):\r\n...\n   232\t\r\n   233\t```javascript\r\n   234\tfunction extractFromWorkflowSession(sessionPath) {\r\n   235\t  // Load session metadata\r\n   236\t  const sessionJson = Read(`${sessionPath}/workflow-session.json`);\r\n   237\t  const session = JSON.parse(sessionJson);\r\n   238\t\r\n   239\t  // Load IMPL_PLAN.md for approach (if exists)\r\n   240\t  let approach = '';\r\n   241\t  const implPlanPath = `${sessionPath}/IMPL_PLAN.md`;\r\n   242\t  const hasImplPlan = Bash(`test -f \"${implPlanPath}\" && echo \"yes\" || echo \"no\"`).trim() === 'yes';\r\n   243\t  if (hasImplPlan) {\r\n   244\t    const implPlan = Read(implPlanPath);\r\n   245\t    // Extract overview/approach section\r\n   246\t    const overviewMatch = implPlan.match(/##\\s*(?:Overview|Approach|Strategy)\\s*\\n([\\s\\S]*?)(?=\\n##|$)/i);\r\n   247\t    approach = overviewMatch?.[1]?.trim() || implPlan.split('\\n').slice(0, 10).join('\\n');\r\n   248\t  }\r\n...\n   327\t      \"implementation\": [\"step 1\", \"step 2\"],\r\n   328\t      \"acceptance\": [\"criteria 1\", \"criteria 2\"]\r\n   329\t    }\r\n   330\t  ]\r\n   331\t}\r\n   332\tCONSTRAINTS: Output ONLY valid JSON - no markdown, no explanation | Action must be one of: Create, Update, Implement, Refactor, Add, Delete, Configure, Test, Fix | Tasks must have id, title, scope, action, implementation (array), acceptance (array)\r\n   333\t\r\n   334\tDOCUMENT CONTENT:\r\n   335\t${fileContent}`;\r\n   336\t\r\n   337\t  // Execute Gemini CLI\r\n   338\t  const result = Bash(`ccw cli -p '${cliPrompt.replace(/'/g, \"'\\\\''\")}' --tool gemini --mode analysis`, { timeout: 120000 });\r\n   339\t\r\n   340\t  // Parse JSON from result (may be wrapped in markdown code block)\r\n   341\t  let jsonText = result.trim();\r\n   342\t  const jsonMatch = jsonText.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\r\n   343\t  if (jsonMatch) {\r\n   344\t    jsonText = jsonMatch[1].trim();\r\n   345\t  }\r\n...\n   659\t\r\n   660\t  // Bind solution to issue\r\n   661\t  try {\r\n   662\t    Bash(`ccw issue bind ${issueId} ${solutionId}`);\r\n   663\t    console.log(`‚úì Bound solution to issue`);\r\n   664\t  } catch (e) {\r\n   665\t    // Cleanup: remove solution file on bind failure\r\n   666\t    try {\r\n   667\t      Bash(`rm -f \"${solutionFile}\"`);\r\n   668\t    } catch (cleanupError) {\r\n   669\t      // Ignore cleanup errors\r\n   670\t    }\r\n   671\t    throw new Error(`Failed to bind solution: ${e.message}`);\r\n   672\t  }\r\n   673\t\r\n   674\t  // Update issue status to planned\r\n   675\t  try {\r\n   676\t    Bash(`ccw issue update ${issueId} --status planned`);\r\n   677\t  } catch (e) {\r\n   678\t    throw new Error(`Failed to update issue status: ${e.message}`);\r\n   679\t  }\r\n   680\t}\r\n...\n\nPath: ccw\\docs-site\\docs\\commands\\issue\\issue-convert-to-plan.md\n     1\t---\r\n     2\ttitle: issue:convert-to-plan\r\n     3\tsidebar_label: issue:convert-to-plan\r\n     4\tsidebar_position: 7\r\n     5\tdescription: Convert planning artifacts to issue solutions\r\n     6\t---\r\n     7\t\r\n     8\t# issue:convert-to-plan\r\n     9\t\r\n    10\tConverts various planning artifact formats (lite-plan, workflow session, markdown, JSON) into issue workflow solutions with intelligent detection and automatic binding.\r\n    11\t\r\n    12\t## Description\r\n    13\t\r\n    14\tThe `issue:convert-to-plan` command bridges external planning workflows with the issue system. It auto-detects source formats, extracts task structures, normalizes to solution schema, and either creates new issues or supplements existing solutions.\r\n    15\t\r\n    16\t### Key Features\r\n    17\t\r\n    18\t- **Multi-format support**: lite-plan, workflow sessions, markdown, JSON\r\n    19\t- **Auto-detection**: Identifies source type automatically\r\n    20\t- **AI-assisted extraction**: Gemini CLI for markdown parsing\r\n    21\t- **Supplement mode**: Add tasks to existing solutions\r\n    22\t- **Auto-binding**: Solutions automatically bound to issues\r\n    23\t- **Issue auto-creation**: Creates issues from plans when needed\r\n    24\t\r\n    25\t## Usage\r\n    26\t\r\n    27\t```bash\r\n    28\t# Convert lite-plan to new issue (auto-creates issue)\r\n    29\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth-2026-01-25\"\r\n    30\t\r\n    31\t# Convert workflow session to existing issue\r\n    32\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    33\t\r\n    34\t# Convert markdown file to issue\r\n    35\t/issue:convert-to-plan \"./docs/implementation-plan.md\"\r\n    36\t\r\n    37\t# Supplement existing solution with additional tasks\r\n    38\t/issue:convert-to-plan \"./docs/additional-tasks.md\" --issue ISS-001 --supplement\r\n    39\t\r\n    40\t# Auto mode - skip confirmations\r\n    41\t/issue:convert-to-plan \".workflow/.lite-plan/my-plan\" -y\r\n    42\t```\r\n    43\t\r\n    44\t### Arguments\r\n    45\t\r\n    46\t| Argument | Required | Description |\r\n    47\t|----------|----------|-------------|\r\n    48\t| `SOURCE` | Yes | Planning artifact path or WFS-xxx ID |\r\n    49\t| `--issue &lt;id&gt;` | No | Bind to existing issue instead of creating new |\r\n    50\t| `--supplement` | No | Add tasks to existing solution (requires --issue) |\r\n    51\t| `-y, --yes` | No | Skip all confirmations |\r\n    52\t\r\n    53\t## Examples\r\n    54\t\r\n    55\t### Convert Lite-Plan\r\n    56\t\r\n    57\t```bash\r\n    58\t/issue:convert-to-plan \".workflow/.lite-plan/implement-auth\"\r\n    59\t# Output:\r\n    60\t# Detected source type: lite-plan\r\n    61\t# Extracted: 5 tasks\r\n    62\t# Created issue: ISS-20250129-001 (priority: 3)\r\n    63\t# ‚úì Created solution: SOL-ISS-20250129-001-a7b3\r\n    64\t# ‚úì Bound solution to issue\r\n    65\t# ‚Üí Status: planned\r\n    66\t```\r\n    67\t\r\n    68\t### Convert Workflow Session\r\n    69\t\r\n    70\t```bash\r\n    71\t/issue:convert-to-plan WFS-auth-impl --issue GH-123\r\n    72\t# Output:\r\n    73\t# Detected source type: workflow-session\r\n    74\t# Loading session: .workflow/active/WFS-auth-impl/\r\n    75\t# Extracted: 8 tasks from session\r\n    76\t# ‚úì Created solution: SOL-GH-123-c9d2\r\n    77\t# ‚úì Bound solution to issue GH-123\r\n    78\t```\r\n    79\t\r\n    80\t### Convert Markdown with AI\r\n    81\t\r\n    82\t```bash\r\n    83\t/issue:convert-to-plan \"./docs/api-redesign.md\"\r\n    84\t# Output:\r\n    85\t# Detected source type: markdown-file\r\n    86\t# Using Gemini CLI for intelligent extraction...\r\n    87\t# Extracted: 6 tasks\r\n    88\t# Created issue: ISS-20250129-002 (priority: 2)\r\n    89\t# ‚úì Created solution: SOL-ISS-20250129-002-e4f1\r\n    90\t```\r\n    91\t\r\n    92\t### Supplement Existing Solution\r\n    93\t\r\n    94\t```bash\r\n    95\t/issue:convert-to-plan \"./docs/tasks-phase2.md\" --issue ISS-001 --supplement\r\n    96\t# Output:\r\n    97\t# Loaded existing solution: SOL-ISS-001-a7b3 (3 tasks)\r\n    98\t# Extracted: 2 new tasks\r\n    99\t# Supplementing: 3 existing + 2 new = 5 total tasks\r\n   100\t# ‚úì Updated solution: SOL-ISS-001-a7b3\r\n   101\t```\r\n   102\t\r\n   103\t## Issue Lifecycle Flow\r\n...\n\nPath: .claude\\commands\\issue\\from-brainstorm.md\n...\n   262\tEOF\r\n   263\t```\r\n   264\t\r\n   265\t### Solution Binding\r\n   266\t```bash\r\n   267\t# Append solution to JSONL file\r\n   268\techo '{\"id\":\"SOL-xxx\",\"tasks\":[...]}' >> .workflow/issues/solutions/{issue-id}.jsonl\r\n   269\t\r\n   270\t# Bind to issue\r\n   271\tccw issue bind {issue-id} {solution-id}\r\n   272\t\r\n   273\t# Update status\r\n   274\tccw issue update {issue-id} --status planned\r\n   275\t```\r\n   276\t\r\n   277\t## Error Handling\r\n   278\t\r\n   279\t| Error | Message | Resolution |\r\n   280\t|-------|---------|------------|\r\n   281\t| Session not found | synthesis.json missing | Check session ID, list available sessions |\r\n   282\t| No ideas | top_ideas array empty | Complete brainstorm workflow first |\r\n   283\t| Invalid idea index | Index out of range | Check valid range 0 to N-1 |\r\n   284\t| Issue creation failed | ccw issue create error | Verify CLI endpoint working |\r\n   285\t| Solution binding failed | Bind error | Check issue exists, retry |\r\n   286\t\r\n   287\t## Examples\r\n...\n\nPath: .claude\\commands\\workflow\\lite-plan.md\n     1\t---\r\n     2\tname: lite-plan\r\n     3\tdescription: Lightweight interactive planning workflow with in-memory planning, code exploration, and execution execute to lite-execute after user confirmation\r\n     4\targument-hint: \"[-y|--yes] [-e|--explore] \\\"task description\\\"|file.md\"\r\n     5\tallowed-tools: TodoWrite(*), Task(*), Skill(*), AskUserQuestion(*)\r\n     6\t---\r\n     7\t\r\n     8\t# Workflow Lite-Plan Command (/workflow:lite-plan)\r\n     9\t\r\n    10\t## Overview\r\n    11\t\r\n    12\tIntelligent lightweight planning command with dynamic workflow adaptation based on task complexity. Focuses on planning phases (exploration, clarification, planning, confirmation) and delegates execution to `/workflow:lite-execute`.\r\n...\n    30\t\r\n    31\t# Arguments\r\n    32\t<task-description>         Task description or path to .md file (required)\r\n    33\t\r\n    34\t# Examples\r\n    35\t/workflow:lite-plan \"ÂÆûÁé∞JWTËÆ§ËØÅ\"                    # Interactive mode\r\n    36\t/workflow:lite-plan --yes \"ÂÆûÁé∞JWTËÆ§ËØÅ\"              # Auto mode (no confirmations)\r\n    37\t/workflow:lite-plan -y -e \"‰ºòÂåñÊï∞ÊçÆÂ∫ìÊü•ËØ¢ÊÄßËÉΩ\"       # Auto mode + force exploration\r\n    38\t```\r\n    39\t\r\n    40\t## Output Artifacts\r\n    41\t\r\n    42\t| Artifact | Description |\r\n    43\t|----------|-------------|\r\n    44\t| `exploration-{angle}.json` | Per-angle exploration results (1-4 files based on complexity) |\r\n    45\t| `explorations-manifest.json` | Index of all exploration files |\r\n    46\t| `planning-context.md` | Evidence paths + synthesized understanding |\r\n    47\t| `plan.json` | Structured implementation plan (plan-json-schema.json) |\r\n...\n\nPath: .claude\\commands\\workflow\\session\\start.md\n     1\t---\r\n     2\tname: start\r\n     3\tdescription: Discover existing sessions or start new workflow session with intelligent session management and conflict detection\r\n     4\targument-hint: [--type <workflow|review|tdd|test|docs>] [--auto|--new] [optional: task description for new session]\r\n     5\texamples:\r\n     6\t  - /workflow:session:start\r\n     7\t  - /workflow:session:start --auto \"implement OAuth2 authentication\"\r\n     8\t  - /workflow:session:start --type review \"Code review for auth module\"\r\n     9\t  - /workflow:session:start --type tdd --auto \"implement user authentication\"\r\n    10\t  - /workflow:session:start --type test --new \"test payment flow\"\r\n    11\t---\r\n...\n    64\t\r\n    65\t**Note**: `/workflow:init` uses cli-explore-agent to build comprehensive project understanding (technology stack, architecture, key components). This step runs once per project. Subsequent executions skip initialization.\r\n    66\t\r\n    67\t## Mode 1: Discovery Mode (Default)\r\n    68\t\r\n    69\t### Usage\r\n    70\t```bash\r\n    71\t/workflow:session:start\r\n    72\t```\r\n    73\t\r\n    74\t### Step 1: List Active Sessions\r\n    75\t```bash\r\n    76\tbash(ls -1 .workflow/active/ 2>/dev/null | head -5)\r\n    77\t```\r\n    78\t\r\n    79\t### Step 2: Display Session Metadata\r\n    80\t```bash\r\n    81\tbash(cat .workflow/active/WFS-promptmaster-platform/workflow-session.json)\r\n    82\t```\r\n    83\t\r\n    84\t### Step 4: User Decision\r\n    85\tPresent session information and wait for user to select or create session.\r\n    86\t\r\n    87\t**Output**: `SESSION_ID: WFS-[user-selected-id]`\r\n    88\t\r\n    89\t## Mode 2: Auto Mode (Intelligent)\r\n    90\t\r\n    91\t### Usage\r\n    92\t```bash\r\n    93\t/workflow:session:start --auto \"task description\"\r\n    94\t```\r\n    95\t\r\n    96\t### Step 1: Check Active Sessions Count\r\n    97\t```bash\r\n    98\tbash(find .workflow/active/ -name \"WFS-*\" -type d 2>/dev/null | wc -l)\r\n    99\t```\r\n   100\t\r\n   101\t### Step 2a: No Active Sessions ‚Üí Create New\r\n   102\t```bash\r\n   103\t# Generate session slug\r\n   104\tbash(echo \"implement OAuth2 auth\" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c1-50)\r\n   105\t\r\n   106\t# Create directory structure\r\n   107\tbash(mkdir -p .workflow/active/WFS-implement-oauth2-auth/.process)\r\n   108\tbash(mkdir -p .workflow/active/WFS-implement-oauth2-auth/.task)\r\n   109\tbash(mkdir -p .workflow/active/WFS-implement-oauth2-auth/.summaries)\r\n...\n   124\t\r\n   125\t# Check keyword match (manual comparison)\r\n   126\t# If task contains project keywords ‚Üí Reuse session\r\n   127\t# If task unrelated ‚Üí Create new session (use Step 2a)\r\n   128\t```\r\n   129\t\r\n   130\t**Output (reuse)**: `SESSION_ID: WFS-promptmaster-platform`\r\n   131\t**Output (new)**: `SESSION_ID: WFS-[new-slug]`\r\n   132\t\r\n   133\t### Step 2c: Multiple Active Sessions ‚Üí Use First\r\n   134\t```bash\r\n   135\t# Get first active session\r\n   136\tbash(find .workflow/active/ -name \"WFS-*\" -type d 2>/dev/null | head -1 | xargs basename)\r\n   137\t\r\n   138\t# Output warning and session ID\r\n   139\t# WARNING: Multiple active sessions detected\r\n   140\t# SESSION_ID: WFS-first-session\r\n   141\t```\r\n   142\t\r\n   143\t## Mode 3: Force New Mode\r\n   144\t\r\n   145\t### Usage\r\n   146\t```bash\r\n   147\t/workflow:session:start --new \"task description\"\r\n   148\t```\r\n...\n\nPath: ccw\\src\\commands\\issue.ts#chunk3of4\n...\n   284\t\r\n   285\t/**\r\n   286\t * bind - Register and/or bind a solution\r\n   287\t */\r\n   288\tasync function bindAction(issueId: string | undefined, solutionId: string | undefined, options: IssueOptions): Promise<void> {\r\n   289\t  if (!issueId) {\r\n   290\t    console.error(chalk.red('Issue ID is required'));\r\n   291\t    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));\r\n   292\t    process.exit(1);\r\n   293\t  }\r\n   294\t\r\n   295\t  const issue = findIssue(issueId);\r\n   296\t  if (!issue) {\r\n   297\t    console.error(chalk.red(`Issue \"${issueId}\" not found`));\r\n   298\t    process.exit(1);\r\n   299\t  }\r\n   300\t\r\n   301\t  let solutions = readSolutions(issueId);\r\n...\n   343\t\r\n   344\t  // Bind the specified solution\r\n   345\t  const solIdx = solutions.findIndex(s => s.id === solutionId);\r\n   346\t  if (solIdx === -1) {\r\n   347\t    console.error(chalk.red(`Solution \"${solutionId}\" not found`));\r\n   348\t    process.exit(1);\r\n   349\t  }\r\n   350\t\r\n   351\t  // Unbind all, bind selected\r\n   352\t  solutions = solutions.map(s => ({ ...s, is_bound: false }));\r\n   353\t  solutions[solIdx].is_bound = true;\r\n   354\t  solutions[solIdx].bound_at = new Date().toISOString();\r\n   355\t\r\n   356\t  writeSolutions(issueId, solutions);\r\n   357\t  updateIssue(issueId, {\r\n   358\t    bound_solution_id: solutionId,\r\n   359\t    status: 'planned',\r\n   360\t    planned_at: new Date().toISOString()\r\n   361\t  });\r\n   362\t\r\n   363\t  console.log(chalk.green(`‚úì Solution ${solutionId} bound to ${issueId}`));\r\n   364\t}\r\n...\n\nPath: .claude\\commands\\workflow\\tools\\test-task-generate.md\n     1\t---\r\n     2\tname: test-task-generate\r\n     3\tdescription: Generate test planning documents (IMPL_PLAN.md, test task JSONs, TODO_LIST.md) by invoking test-action-planning-agent\r\n     4\targument-hint: \"--session WFS-test-session-id\"\r\n     5\texamples:\r\n     6\t  - /workflow:tools:test-task-generate --session WFS-test-auth\r\n     7\t---\r\n     8\t\r\n     9\t# Generate Test Planning Documents Command\r\n    10\t\r\n    11\t## Overview\r\n    12\t\r\n    13\tGenerate test planning documents (IMPL_PLAN.md, test task JSONs, TODO_LIST.md) by invoking **test-action-planning-agent**.\r\n    14\t\r\n    15\tThis command produces **test planning artifacts only** - it does NOT execute tests or implement code. Actual test execution requires separate execution command (e.g., /workflow:test-cycle-execute).\r\n    16\t\r\n    17\t### Agent Specialization\r\n...\n\nPath: ccw\\src\\commands\\issue.ts#chunk4of4\n...\n   704\t      console.log(chalk.gray('  solution <id> --brief              Brief: solution_id, files_touched, task_count'));\r\n   705\t      console.log(chalk.gray('  solution <id> --data \\'{...}\\'       Create solution (auto-generates ID)'));\r\n   706\t      console.log(chalk.gray('  bind <issue-id> [sol-id]           Bind solution'));\r\n   707\t      console.log(chalk.gray('  update <issue-id> --status <s>     Update issue status'));\r\n   708\t      console.log(chalk.gray('  update --from-queue [queue-id]     Sync statuses from queue (default: active)'));\r\n   709\t      console.log();\r\n   710\t      console.log(chalk.bold('Queue Commands:'));\r\n   711\t      console.log(chalk.gray('  queue                              Show active queue'));\r\n   712\t      console.log(chalk.gray('  queue list                         List all queues (history)'));\r\n...\n\nPath: .claude\\commands\\workflow\\lite-execute.md\n...\n   540\t  - Recommendations\r\n   541\t  Explicitly check each acceptance criterion and verification item from plan.json tasks.\r\n   542\tCONSTRAINTS: Focus on plan acceptance criteria, verification requirements, and plan adherence | analysis=READ-ONLY\r\n   543\t```\r\n   544\t\r\n   545\t**Tool-Specific Execution** (Apply shared prompt template above):\r\n   546\t\r\n   547\t```bash\r\n   548\t# Method 1: Agent Review (current agent)\r\n   549\t# - Read plan.json: ${executionContext.session.artifacts.plan}\r\n   550\t# - Apply unified review criteria (see Shared Prompt Template)\r\n   551\t# - Report findings directly\r\n   552\t\r\n   553\t# Method 2: Gemini Review (recommended)\r\n   554\tccw cli -p \"[Shared Prompt Template with artifacts]\" --tool gemini --mode analysis\r\n   555\t# CONTEXT includes: @**/* @${plan.json} [@${exploration.json}]\r\n...\n\nPath: .claude\\commands\\workflow\\session\\complete.md\n...\n    10\t\r\n    11\t# Complete Workflow Session (/workflow:session:complete)\r\n    12\t\r\n    13\tMark the currently active workflow session as complete, archive it, and update manifests.\r\n    14\t\r\n    15\t## Pre-defined Commands\r\n    16\t\r\n    17\t```bash\r\n    18\t# Phase 1: Find active session\r\n    19\tSESSION_PATH=$(find .workflow/active/ -maxdepth 1 -name \"WFS-*\" -type d | head -1)\r\n    20\tSESSION_ID=$(basename \"$SESSION_PATH\")\r\n    21\t\r\n    22\t# Phase 3: Move to archive\r\n    23\tmkdir -p .workflow/archives/\r\n    24\tmv .workflow/active/$SESSION_ID .workflow/archives/$SESSION_ID\r\n    25\t\r\n    26\t# Cleanup marker\r\n    27\trm -f .workflow/archives/$SESSION_ID/.archiving\r\n    28\t```\r\n    29\t\r\n    30\t## Key Files to Read\r\n    31\t\r\n    32\t**For manifest.json generation**, read ONLY these files:\r\n...\n\n",
      "type": "text"
    }
  ]
}

thinking
**Evaluating documentation for CLI operations**

I need to outline that we‚Äôre using the CLI for issue operations. However, as a slash command, it may still create paths like `.workflow/.scratchpad/...`. I plan to check the convert-to-plan document for artifact paths used. It‚Äôs important to keep the spec minimal, so I‚Äôll scan the document for terms like "Writes" or specific paths. Using shell or ACE for the search is a good idea, and I can utilize `Select-String` for this task.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/issue/convert-to-plan.md -Pattern "'"\\.workflow/\" | Select-Object -First 50 | ForEach-Object { "'$_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 332ms:
- **lite-plan**: `.workflow/.lite-plan/{slug}/plan.json`
- **workflow-session**: `WFS-xxx` ID or `.workflow/active/{session}/` folder
/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
    return { type: 'workflow-session-id', path: `.workflow/active/${source}` };
Bash(`mkdir -p .workflow/issues/solutions`);
const solutionFile = `.workflow/issues/solutions/${issueId}.jsonl`;
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/**/*.ts -Pattern "'"\\.workflow/issues/solutions\" -List | Select-Object -First 20 | ForEach-Object { "'$_.Path }' in C:\Project\Claude-Code-Workflow succeeded in 363ms:
C:\Project\Claude-Code-Workflow\ccw\src\commands\issue.ts

thinking
**Evaluating issue tracking**

I'm looking at the issue tracking in great issue.ts, which includes a specific string I'm interested in. I can use the evidence anchor `.workflow/issues/solutions` to point the row. The evidence script checks if the anchor literally includes that string, so it's all good there. If the directory for that pointer exists, I should mark it as Existing; if not, I can classify it as Planned. To confirm, I'll check using `Test-Path`.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
if (Test-Path .workflow/issues/solutions) { '"'EXISTS' } else { 'MISSING' }" in C:\Project\Claude-Code-Workflow succeeded in 313ms:
MISSING
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/**/*.md -Pattern "Solution Schema" -List | Select-Object -First 20 | ForEach-Object { $_.Path }' in C:\Project\Claude-Code-Workflow succeeded in 335ms:
C:\Project\Claude-Code-Workflow\.claude\commands\issue\convert-to-plan.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\from-brainstorm.md
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/**/*.md -Pattern "ccw issue bind" -List | Select-Object -First 20 | ForEach-Object { $_.Path }' in C:\Project\Claude-Code-Workflow succeeded in 328ms:
C:\Project\Claude-Code-Workflow\.claude\commands\issue\convert-to-plan.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\from-brainstorm.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\plan.md

thinking
**Inspecting command patterns**

I'm looking into the issue with plan.md and inspecting the headings to see what we can use as a candidate. I‚Äôll search for `ccw cli -p` using Gemini to find any relevant patterns. Also, I'll check the `.claude/commands` folder for any occurrences of `--tool gemini`. It feels like there‚Äôs a method in this madness, and hopefully, these searches will clarify everything!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/**/*.md -Pattern "--tool gemini" -List | Select-Object -First 20 | ForEach-Object { $_.Path }' in C:\Project\Claude-Code-Workflow succeeded in 334ms:
C:\Project\Claude-Code-Workflow\.claude\commands\cli\cli-init.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\convert-to-plan.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\discover-by-prompt.md
C:\Project\Claude-Code-Workflow\.claude\commands\issue\execute.md
C:\Project\Claude-Code-Workflow\.claude\commands\memory\docs-full-cli.md
C:\Project\Claude-Code-Workflow\.claude\commands\memory\docs-related-cli.md
C:\Project\Claude-Code-Workflow\.claude\commands\memory\load.md
C:\Project\Claude-Code-Workflow\.claude\commands\memory\update-full.md
C:\Project\Claude-Code-Workflow\.claude\commands\memory\update-related.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\analyze-with-file.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\brainstorm-with-file.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\debug-with-file.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\lite-execute.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\plan-verify.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\review.md
C:\Project\Claude-Code-Workflow\.claude\commands\workflow\unified-execute-with-file.md

thinking
**Extracting exact string**

I need to ensure I'm capturing the exact string from the file for the evidence cell. This means using the `includes` method precisely, including all spaces. I'll extract the exact line using shell commands to avoid mismatches. My plan is to use Select-String to find "Usage: ccw issue bind" in issue.ts and display that specific line. Copying it exactly will be crucial for accuracy!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "Usage: ccw issue bind" | Select-Object -First 5 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 323ms:
    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));

thinking
I'm looking for the right usage pattern for the command `ccw issue bind <issue-id> [solution-id] [--solution <path>]`. I want to ensure I have the exact punctuation and spacing down. I should also check the usage for `ccw issue status` in the same file, `issue.ts`. I might need to refer to these commands later, so it‚Äôs important to have them precise. Let's get this sorted so I can keep everything organized!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "issue status" | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 317ms:
 * Validate issue status
  // Update issue status (solution = issue in new model)
              // Reset issue status to 'queued' for re-execution
          // Reset QueueItem for retry (Issue status also reset to 'queued')
      console.log(chalk.gray('  update <issue-id> --status <s>     Update issue status'));

thinking
I‚Äôm thinking that maybe there's a status subcommand I could use, especially if it comes with a usage string. I should search for something like "status <issue-id>" or ‚ÄúUsage: ccw issue status‚Äù to see if I can find more details on how to check the status of an issue. It seems like that might be a straightforward way to get the information I need! Let‚Äôs go ahead and look that up.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "ccw issue status" | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 311ms:


thinking
**Searching for command status**

I‚Äôm checking if there‚Äôs a command for "status" that displays actions related to an issue. I should search for ‚Äústatus <id>‚Äù in the help lines to see if there‚Äôs any specific information on that. I want to ensure I understand how to properly use the command and what the expected outputs are. So let's look into that and clarify what‚Äôs available in the help documentation!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "status" | Select-Object -First 50 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 331ms:
 * Commands: init, list, status, task, bind, queue, next, done, retry
  status: 'registered' | 'planning' | 'planned' | 'queued' | 'executing' | 'completed' | 'failed' | 'paused';
  status?: string;
  status: 'pending' | 'ready' | 'executing' | 'completed' | 'failed' | 'blocked';
  status: 'active' | 'completed' | 'archived' | 'failed';
    status: string;
  status?: string;
  brief?: boolean;      // List brief info only (id, title, status, priority, tags) - JSON format
  fromQueue?: boolean | string;  // Sync statuses from queue (true=active, string=specific queue ID)
// ============ Status Constants ============
const VALID_QUEUE_STATUSES = ['active', 'completed', 'archived', 'failed'] as const;
const VALID_ITEM_STATUSES = ['pending', 'ready', 'executing', 'completed', 'failed', 'blocked'] as const;
const VALID_ISSUE_STATUSES = ['registered', 'planning', 'planned', 'queued', 'executing', 'completed', 'failed', 'paused'] as const;
type QueueStatus = typeof VALID_QUEUE_STATUSES[number];
type QueueItemStatus = typeof VALID_ITEM_STATUSES[number];
type IssueStatus = typeof VALID_ISSUE_STATUSES[number];
 * Validate queue status
function validateQueueStatus(status: string): status is QueueStatus {
  return VALID_QUEUE_STATUSES.includes(status as QueueStatus);
 * Validate queue item status

thinking
**Searching for usage strings**

I‚Äôm looking for the `ccw issue status` usage string since there was a comment about `ccw issue solutions --status planned --brief`. I think searching for "Usage: ccw issue" might be a good way to locate what I need. It would ensure I have the right information and context for whatever task I‚Äôm working on! Let‚Äôs see what I can find with that search!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "Usage: ccw issue" | Select-Object -First 50 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 331ms:
 * Usage: ccw issue create --data '{"title":"...", "context":"..."}'
    console.error(chalk.gray('Usage: ccw issue create --data \'{"title":"...", "context":"..."}\''));
 * Usage: ccw issue pull [--state open|closed|all] [--limit N] [--labels label1,label2]
    console.error(chalk.gray('Usage: ccw issue solution <issue-id> [--brief] [--solution-id <id>]'));
 * Usage: ccw issue solutions --status planned --brief
    console.error(chalk.gray('Usage: ccw issue init <issue-id> [--title "..."]'));
    console.error(chalk.gray('Usage: ccw issue task <issue-id> [task-id] --title "..."'));
    console.error(chalk.gray('Usage: ccw issue update <issue-id> --status <status>'));
    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));
      console.error(chalk.gray('Usage: ccw issue queue merge <source-id> --queue <target-id>'));
    console.error(chalk.gray('Usage: ccw issue done <item-id> [--fail] [--reason "..."] [--queue <queue-id>]'));

thinking
**Investigating usage strings**

I‚Äôm noticing that the output lists usage strings for create, pull, solution, and a few others like init and task, but there‚Äôs no string for status. I‚Äôm wondering if status might not have an associated usage string because it consistently uses `ccw issue status <id>`. Maybe it's not in the first 50 because of the search limitations? I think it‚Äôd be helpful to search for ‚Äúissue status <‚Äù to see what pops up.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "issue status" -Context 0,2 | Select-Object -First 50 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 317ms:
 * Validate issue status
  // Update issue status (solution = issue in new model)
              // Reset issue status to 'queued' for re-execution
          // Reset QueueItem for retry (Issue status also reset to 'queued')
      console.log(chalk.gray('  update <issue-id> --status <s>     Update issue status'));

thinking
**Evaluating command status**

I see the command document says to use `ccw issue status <id> --json`. However, the TypeScript (TS) doesn‚Äôt seem to have a usage string for status. Maybe it‚Äôs something like `statusAction` that‚Äôs handled differently? I‚Äôll need to find a TS anchor that lists commands, which includes `status`, to confirm. For instance, I could find a comment that outlines commands like `init, list, status, task`, or look for the function name `statusAction`. Let‚Äôs search for "statusAction."
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "statusAction" -List | ForEach-Object { $_.Path }' in C:\Project\Claude-Code-Workflow succeeded in 318ms:
C:\Project\Claude-Code-Workflow\ccw\src\commands\issue.ts
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "statusAction" | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 325ms:
async function statusAction(issueId: string | undefined, options: IssueOptions): Promise<void> {
      await statusAction(argsArray[0], options);

thinking
**Identifying function anchors**

I'm identifying the function anchors we can use as evidence for the status command, like `async function statusAction(` and similarly for `initAction`. For the `issue init`, there's a usage string I want to leverage, perhaps looking at `async function initAction(` for that too. My goal is to locate these effectively so we can reference them correctly!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "async function initAction" | Select-Object -First 10 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 324ms:
async function initAction(issueId: string | undefined, options: IssueOptions): Promise<void> {
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "solutionsAction" | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 316ms:
async function solutionsAction(options: IssueOptions): Promise<void> {
      await solutionsAction(options);

thinking
**Determining command anchors**

I‚Äôm focusing on commands related to scanning. First, I need to look for specific anchors in the commands-routes. It seems that I should concentrate on the lines that include `scanCommandsRecursive`. This will help me find the right spot to get everything set up properly. Making sure I have the correct lines will ensure I can proceed effectively. It's all about being precise with these commands!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/core/routes/commands-routes.ts -Pattern "scanCommandsRecursive" | Select-Object -First 10 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
function scanCommandsRecursive(
        results.push(...scanCommandsRecursive(baseDir, fullPath, location, projectPath));
    result.projectCommands = scanCommandsRecursive(projectDir, projectDir, 'project', projectPath);
    result.userCommands = scanCommandsRecursive(userDir, userDir, 'user', projectPath);
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/core/routes/issue-routes.ts -Pattern "function bindSolutionToIssue" | Select-Object -First 5 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 316ms:
function bindSolutionToIssue(issuesDir: string, issueId: string, solutionId: string, issues: any[], issueIndex: number) {
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/issue/convert-to-plan.md -Pattern "''^#{1,6} " | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
## Auto Mode
# Issue Convert-to-Plan Command (/issue:convert-to-plan)
## Overview
## Quick Reference
# Convert lite-plan to new issue (auto-creates issue)
# Convert workflow session to existing issue
# Supplement existing solution with additional tasks
# Auto mode - skip confirmations
## Command Options
## Core Data Access Principle
## Solution Schema Reference
## Implementation
### Phase 1: Parse Arguments & Detect Source Type
### Phase 2: Extract Data Using Format-Specific Extractor
#### Extractor: Lite-Plan
#### Extractor: Workflow Session
#### Extractor: Markdown (AI-Assisted via Gemini)
#### Extractor: JSON File
### Phase 3: Normalize Task IDs
### Phase 4: Resolve Issue (Create or Find)




thinking
**Planning documentation structures**

I can provide documentation evidence from either "convert-to-plan" or "from-brainstorm," but I'll need a heading. I want to keep the pointers list small while still covering key implementation areas. Creating a gap report with P0 gaps is essential too. For those P0 gaps, I'll ensure the command uses CLI for issue operations and that detection of source type and JSON parsing are robust. I'll focus on highlighting missing details in the outline, not the actual code.
thinking
**Ensuring proper file paths and verification**

I need to include values in the `generated-agent-outline.md` as an agent outline template. The skill specifies that evidence tables in both the gap report and slash outline must pass a verification script. After generating the files, I‚Äôll run the verification on these two files. It's crucial that I create the output files in the user-specified directory, not just the root. Also, I have to ensure that the paths use forward slashes with the correct casing.
thinking
**Clarifying evidence file requirements**

The TS evidence file needs to start with `ccw/src/` and end with .ts, .tsx, or .js. I'll be using files like `ccw/src/commands/issue.ts` for that purpose. The verify-evidence script checks file existence using safeResolve, which works fine with forward slashes. The docs heading in the evidence should match, and I‚Äôm considering using "Overview" for consistency. For anchors, I‚Äôll select exact substrings. I‚Äôll also outline which pointer rows to include in the slash outline evidence table.
thinking
**Verifying file paths and evidence**

If I mark something as Existing, the pathExists check will apply successfully. It‚Äôs important to note that fileExists is only for evidence files, not pointers. However, marking it as Existing means I‚Äôll ensure the path actually exists. I‚Äôll use the command `Test-Path .claude/workflows/.../solution-schema.json` to check this. The docs heading will be "Solution Schema Reference," and I'll need to choose the TS evidence anchor from the `issue.ts`, specifically the `bound_solution_id:` string. Let's confirm that in the file.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "bound_solution_id" | Select-Object -First 5 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
  bound_solution_id: string | null;
    bound_solution_id: data.bound_solution_id || null,
  // Filter to only issues with bound_solution_id
  const boundIssues = targetIssues.filter((i: Issue) => i.bound_solution_id);
    const boundSolution = solutions.find(s => s.id === issue.bound_solution_id);


thinking
**Clarifying pointer cell requirements**

It seems that the pointer cell should accommodate spaces and some scripting symbols. The template hints at potential code locations, implying that pointers and evidence tables might be involved. Each row is intended to use documentation and usage strings as evidence for CLI commands. However, the verification checks focus on whether a pointer is missing or just a placeholder, while also enforcing that each pointer must be single and verifiable. I'll ensure that.
thinking
**Ensuring evidence row integrity**

I need to confirm that every evidence row includes a verification command, not just for existing items but also for planned ones. I‚Äôll aim for consistency throughout the gap-report evidence table by aligning it with the outlined pointers. We should include all key pointers and any relevant references like `.claude/commands/issue/from-brainstorm.md`. Each row must feature documentation evidence and a TypeScript anchor, while also avoiding placeholders in the rows. Crafting concise outline content will be based on existing command documentation.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/issue/from-brainstorm.md -Pattern "''^#{1,6} " | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 323ms:
## Auto Mode
# Issue From-Brainstorm Command (/issue:from-brainstorm)
## Overview
## Quick Reference
# Interactive mode - select idea, confirm before creation
# Pre-select idea by index
# Auto mode - select highest scored, no confirmations
## Arguments
## Data Structures
### Issue Schema (Output)
### Solution Schema (Output)
## Execution Flow
## Context Enrichment Logic
### Base Context (Always Included)
### Enhanced Context (If Available)
## Task Generation Strategy
### Task 1: Research & Validation
### Task 2: Design & Specification
### Task 3+: Implementation Tasks
### Fallback Task
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path .claude/commands/issue/convert-to-plan.md -Pattern "ccw issue solution" | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
| List solutions | `ccw issue solutions --issue <id> --brief` | Read solutions/*.jsonl |
      const solResult = Bash(`ccw issue solution ${issue.bound_solution_id} --json`).trim();
- \`ccw issue solution ${flags.supplement ? existingSolution.id : solutionId}\` ‚Üí View solution
- `ccw issue solution <id>` - View solution details
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "writeSolutions" | Select-Object -First 10 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 335ms:
export function writeSolutions(issueId: string, solutions: Solution[]): void {
  writeSolutions(issueId, solutions);
    writeSolutions(issueId, solutions);
    writeSolutions(issueId, solutions);
  writeSolutions(issueId, solutions);

thinking
**Planning file creation**

I'm figuring out how to create an output directory. I can use the shell command to do it, but I noticed we have a write_file tool that can automatically create directories, which might be preferable. I see that it's in the functions namespace as mcp__ccw-tools__write_file.

I need to verify if encoding will be set correctly. The verify-evidence script uses the actual filesystem and confirms the output path exists. Now, I need to create a plan because this is a substantial task, especially with multi-file generation and validation. I'll use the update_plan tool for this.
Plan update
  ‚úì Collect skill templates/quality gates + parse requirement doc for CMD-010
  ‚Üí Locate verifiable docs headings and TS anchor strings for evidence tables
  ‚Ä¢ Draft spec.json + references.json (non-leaky, concise)
  ‚Ä¢ Generate generated-slash-outline.md + generated-agent-outline.md using templates
  ‚Ä¢ Generate gap-report.md + fix-plan.md and ensure evidence tables cover all pointers
  ‚Ä¢ Run deterministic gate: node verify-evidence.js on gap-report and slash outline; iterate until pass



thinking
**Locating evidence anchors**

I'm working on step 2: locating evidence anchors, and there are many to consider. I think it might be useful to reference some document headings from the brainstorming phase for a references.json file, but it's not strictly necessary. I also want to find additional TS anchors for the "ccw issue solution." It seems like an evidence table could include key pointers, particularly for CLI commands like `ccw issue bind` and `ccw issue init`. If these commands are mentioned in the outline, they might deserve their own pointer rows, but maybe just keeping it to key file paths is more efficient.
thinking
**Finalizing evidence pointers**

To be safe, I'm thinking of including pointer rows for the CLI commands too, which will help ensure there's evidence for each one. However, I worry that adding more rows increases the chance of making mistakes‚Äîeven though I think it‚Äôs manageable. The user mentioned we should provide dual-source evidence for any pointer row. So, I might limit the evidence table to major file paths and output directories and mention CLI commands in the execution process without making them pointers. This seems like a balanced approach!
thinking
**Verifying TS anchors**

I need to verify that each TS anchor exists, and I believe we've already checked that the document headings are in place, so that should be good. Now, we also need to validate the references.json, but we'll only include candidates. Since there's no script to validate it, I‚Äôll confirm that `.claude/commands/issue/plan.md` exists and has the proper headings. This seems straightforward, so let's check that quickly to ensure everything is in order!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Test-Path .claude/commands/issue/plan.md; Test-Path .claude/commands/issue/discover-by-prompt.md; Test-Path .claude/commands/workflow/lite-execute.md; Test-Path .claude/commands/cli/cli-init.md' in C:\Project\Claude-Code-Workflow succeeded in 315ms:
True
True
True
True

thinking
**Completing plan steps**

I'm moving step 2 closer to completion after collecting some important anchors. I have a list of items to use, like `async function bindAction(`, `function scanCommandsRecursive(`, and others, including documentation headings like "Overview" and "Core Data Access Principle." It‚Äôs really important to ensure that each evidence row corresponds to an existing documentation heading. Now that I have everything, step 2 is done, and I‚Äôll update the plan accordingly.
Plan update
Found concrete docs headings in .claude/commands/issue/convert-to-plan.md and literal TS anchors in ccw/src (issue command + routes) for evidence tables; also verified .workflow/issues/solutions is currently missing so must be Planned.
  ‚úì Collect skill templates/quality gates + parse requirement doc for CMD-010
  ‚úì Locate verifiable docs headings and TS anchor strings for evidence tables
  ‚Üí Draft spec.json + references.json (non-leaky, concise)
  ‚Ä¢ Generate generated-slash-outline.md + generated-agent-outline.md using templates
  ‚Ä¢ Generate gap-report.md + fix-plan.md and ensure evidence tables cover all pointers
  ‚Ä¢ Run deterministic gate: node verify-evidence.js on gap-report and slash outline; iterate until pass
tool ccw-tools.write_file({"path":".workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json","content":"{\n  \"command\": {\n    \"group\": \"issue\",\n    \"name\": \"convert-to-plan\",\n    \"description\": \"Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions\",\n    \"argument_hint\": \"[-y|--yes] [--issue <id>] [--supplement] <SOURCE>\",\n    \"allowed_tools\": [\n      \"TodoWrite(*)\",\n      \"Bash(*)\",\n      \"Read(*)\",\n      \"Write(*)\",\n      \"Glob(*)\",\n      \"AskUserQuestion(*)\"\n    ]\n  },\n  \"intent\": {\n    \"type\": \"plan\",\n    \"interaction\": \"iterative\",\n    \"primary_user_value\": \"Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue).\"\n  },\n  \"artifacts\": {\n    \"reads\": [\n      \".workflow/.lite-plan/**/plan.json\",\n      \".workflow/active/WFS-*/workflow-session.json\",\n      \".workflow/active/WFS-*/IMPL_PLAN.md\",\n      \".workflow/active/WFS-*/.task/IMPL-*.json\",\n      \"<SOURCE>.md\",\n      \"<SOURCE>.json\",\n      \".claude/workflows/cli-templates/schemas/solution-schema.json\"\n    ],\n    \"writes\": [\n      \".workflow/issues/solutions\",\n      \".workflow/issues/solutions/<issue-id>.jsonl\"\n    ]\n  },\n  \"constraints\": {\n    \"max_rounds\": 2,\n    \"time_budget_seconds\": 180,\n    \"must_not\": [\n      \"Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.\",\n      \"Do not skip confirmation unless -y/--yes is provided.\",\n      \"Do not claim implementation pointers are Existing unless they are verifiable in the repo.\"\n    ]\n  },\n  \"acceptance\": {\n    \"p0\": [\n      \"Frontmatter includes name/description/argument-hint/allowed-tools\",\n      \"Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file\",\n      \"Implements flags: --issue, --supplement, -y/--yes\",\n      \"Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI\",\n      \"Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations\"\n    ]\n  }\n}\n","encoding":"utf8","createDirectories":true})
ccw-tools.write_file({"path":".workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json","content":"{\n  \"command\": {\n    \"group\": \"issue\",\n    \"name\": \"convert-to-plan\",\n    \"description\": \"Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions\",\n    \"argument_hint\": \"[-y|--yes] [--issue <id>] [--supplement] <SOURCE>\",\n    \"allowed_tools\": [\n      \"TodoWrite(*)\",\n      \"Bash(*)\",\n      \"Read(*)\",\n      \"Write(*)\",\n      \"Glob(*)\",\n      \"AskUserQuestion(*)\"\n    ]\n  },\n  \"intent\": {\n    \"type\": \"plan\",\n    \"interaction\": \"iterative\",\n    \"primary_user_value\": \"Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue).\"\n  },\n  \"artifacts\": {\n    \"reads\": [\n      \".workflow/.lite-plan/**/plan.json\",\n      \".workflow/active/WFS-*/workflow-session.json\",\n      \".workflow/active/WFS-*/IMPL_PLAN.md\",\n      \".workflow/active/WFS-*/.task/IMPL-*.json\",\n      \"<SOURCE>.md\",\n      \"<SOURCE>.json\",\n      \".claude/workflows/cli-templates/schemas/solution-schema.json\"\n    ],\n    \"writes\": [\n      \".workflow/issues/solutions\",\n      \".workflow/issues/solutions/<issue-id>.jsonl\"\n    ]\n  },\n  \"constraints\": {\n    \"max_rounds\": 2,\n    \"time_budget_seconds\": 180,\n    \"must_not\": [\n      \"Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.\",\n      \"Do not skip confirmation unless -y/--yes is provided.\",\n      \"Do not claim implementation pointers are Existing unless they are verifiable in the repo.\"\n    ]\n  },\n  \"acceptance\": {\n    \"p0\": [\n      \"Frontmatter includes name/description/argument-hint/allowed-tools\",\n      \"Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file\",\n      \"Implements flags: --issue, --supplement, -y/--yes\",\n      \"Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI\",\n      \"Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations\"\n    ]\n  }\n}\n","encoding":"utf8","createDirectories":true}) failed in 0ms:
tool ccw-tools.write_file({"path":".workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json","content":"{\n  \"candidates\": [\n    {\n      \"slash\": \"/issue:from-brainstorm\",\n      \"file_path\": \".claude/commands/issue/from-brainstorm.md\",\n      \"score\": 0.95,\n      \"why\": \"Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding.\"\n    },\n    {\n      \"slash\": \"/issue:plan\",\n      \"file_path\": \".claude/commands/issue/plan.md\",\n      \"score\": 0.78,\n      \"why\": \"Issue planning workflow; overlaps in solution lifecycle and binding semantics.\"\n    },\n    {\n      \"slash\": \"/issue:discover-by-prompt\",\n      \"file_path\": \".claude/commands/issue/discover-by-prompt.md\",\n      \"score\": 0.72,\n      \"why\": \"Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns.\"\n    },\n    {\n      \"slash\": \"/workflow:lite-execute\",\n      \"file_path\": \".claude/commands/workflow/lite-execute.md\",\n      \"score\": 0.62,\n      \"why\": \"Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations.\"\n    },\n    {\n      \"slash\": \"/workflow:plan-verify\",\n      \"file_path\": \".claude/commands/workflow/plan-verify.md\",\n      \"score\": 0.55,\n      \"why\": \"Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks.\"\n    }\n  ],\n  \"selected\": {\n    \"slash\": \"/issue:from-brainstorm\",\n    \"file_path\": \".claude/commands/issue/from-brainstorm.md\",\n    \"why\": \"Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration.\"\n  }\n}\n","encoding":"utf8","createDirectories":true})
ccw-tools.write_file({"path":".workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json","content":"{\n  \"candidates\": [\n    {\n      \"slash\": \"/issue:from-brainstorm\",\n      \"file_path\": \".claude/commands/issue/from-brainstorm.md\",\n      \"score\": 0.95,\n      \"why\": \"Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding.\"\n    },\n    {\n      \"slash\": \"/issue:plan\",\n      \"file_path\": \".claude/commands/issue/plan.md\",\n      \"score\": 0.78,\n      \"why\": \"Issue planning workflow; overlaps in solution lifecycle and binding semantics.\"\n    },\n    {\n      \"slash\": \"/issue:discover-by-prompt\",\n      \"file_path\": \".claude/commands/issue/discover-by-prompt.md\",\n      \"score\": 0.72,\n      \"why\": \"Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns.\"\n    },\n    {\n      \"slash\": \"/workflow:lite-execute\",\n      \"file_path\": \".claude/commands/workflow/lite-execute.md\",\n      \"score\": 0.62,\n      \"why\": \"Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations.\"\n    },\n    {\n      \"slash\": \"/workflow:plan-verify\",\n      \"file_path\": \".claude/commands/workflow/plan-verify.md\",\n      \"score\": 0.55,\n      \"why\": \"Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks.\"\n    }\n  ],\n  \"selected\": {\n    \"slash\": \"/issue:from-brainstorm\",\n    \"file_path\": \".claude/commands/issue/from-brainstorm.md\",\n    \"why\": \"Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration.\"\n  }\n}\n","encoding":"utf8","createDirectories":true}) failed in 0ms:
file update
A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
{
  "candidates": [
    {
      "slash": "/issue:from-brainstorm",
      "file_path": ".claude/commands/issue/from-brainstorm.md",
      "score": 0.95,
      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
    },
    {
      "slash": "/issue:plan",
      "file_path": ".claude/commands/issue/plan.md",
      "score": 0.78,
      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
    },
    {
      "slash": "/issue:discover-by-prompt",
      "file_path": ".claude/commands/issue/discover-by-prompt.md",
      "score": 0.72,
      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
    },
    {
      "slash": "/workflow:lite-execute",
      "file_path": ".claude/commands/workflow/lite-execute.md",
      "score": 0.62,
      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
    },
    {
      "slash": "/workflow:plan-verify",
      "file_path": ".claude/commands/workflow/plan-verify.md",
      "score": 0.55,
      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
    }
  ],
  "selected": {
    "slash": "/issue:from-brainstorm",
    "file_path": ".claude/commands/issue/from-brainstorm.md",
    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
  }
}

A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
{
  "command": {
    "group": "issue",
    "name": "convert-to-plan",
    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
    "allowed_tools": [
      "TodoWrite(*)",
      "Bash(*)",
      "Read(*)",
      "Write(*)",
      "Glob(*)",
      "AskUserQuestion(*)"
    ]
  },
  "intent": {
    "type": "plan",
    "interaction": "iterative",
    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
  },
  "artifacts": {
    "reads": [
      ".workflow/.lite-plan/**/plan.json",
      ".workflow/active/WFS-*/workflow-session.json",
      ".workflow/active/WFS-*/IMPL_PLAN.md",
      ".workflow/active/WFS-*/.task/IMPL-*.json",
      "<SOURCE>.md",
      "<SOURCE>.json",
      ".claude/workflows/cli-templates/schemas/solution-schema.json"
    ],
    "writes": [
      ".workflow/issues/solutions",
      ".workflow/issues/solutions/<issue-id>.jsonl"
    ]
  },
  "constraints": {
    "max_rounds": 2,
    "time_budget_seconds": 180,
    "must_not": [
      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
      "Do not skip confirmation unless -y/--yes is provided.",
      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
    ]
  },
  "acceptance": {
    "p0": [
      "Frontmatter includes name/description/argument-hint/allowed-tools",
      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
      "Implements flags: --issue, --supplement, -y/--yes",
      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
    ]
  }
}

apply_patch(auto_approved=true) exited 0 in 59ms:
Success. Updated the following files:
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Updating task status**

I‚Äôm moving forward with my plan! I just completed step 3, so I‚Äôll note that as done. Now, I‚Äôm on step 4, which is currently in progress. It feels good to check off a completed step, and I‚Äôm curious about how I‚Äôll tackle the next one. Let‚Äôs keep the momentum going and stay focused on completing this plan efficiently!
Plan update
Wrote minimal non-leaky spec.json + references.json under the cycle output folder (selected /issue:from-brainstorm as closest reference).
  ‚úì Collect skill templates/quality gates + parse requirement doc for CMD-010
  ‚úì Locate verifiable docs headings and TS anchor strings for evidence tables
  ‚úì Draft spec.json + references.json (non-leaky, concise)
  ‚Üí Generate generated-slash-outline.md + generated-agent-outline.md using templates
  ‚Ä¢ Generate gap-report.md + fix-plan.md and ensure evidence tables cover all pointers
  ‚Ä¢ Run deterministic gate: node verify-evidence.js on gap-report and slash outline; iterate until pass
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

file update
A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
# Agent Outline: issue:convert-to-plan

## Purpose

Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.

## Execution Model

- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
- Confirmation-first: auto mode only when `-y/--yes` is present

## State & Artifacts

- Inputs:
  - lite-plan: `.workflow/.lite-plan/**/plan.json`
  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
- Outputs:
  - `.workflow/issues/solutions/<issue-id>.jsonl`
  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`

## Tooling

- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
- Non-negotiables:
  - do not directly edit issue stores for operations that have a CLI equivalent
  - no unrelated changes outside the command implementation
  - keep evidence-based pointers (Existing vs Planned) accurate

## Validation Strategy

- P0 gates:
  - frontmatter + allowed-tools + core sections + no broken artifact references
  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
- Behavioral checks:
  - one example per source type + supplement + auto mode
  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message

A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
---
name: convert-to-plan
description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
group: issue
---

# Issue Convert-to-Plan Command (/issue:convert-to-plan)

## Overview

- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
- Command: `/issue:convert-to-plan`

## Usage

```bash
/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
```

## Inputs

- Required inputs:
  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
- Optional inputs:
  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
  - `--supplement`: add tasks to an existing solution (requires `--issue`)
  - `-y, --yes`: skip confirmations (auto mode)

## Outputs / Artifacts

- Writes:
  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
- Reads:
  - `.workflow/.lite-plan/**/plan.json`
  - `.workflow/active/WFS-*/workflow-session.json`
  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
  - `.workflow/active/WFS-*/.task/IMPL-*.json`
  - `<SOURCE>.md` / `<SOURCE>.json`
  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)

## Implementation Pointers

- Command doc: `.claude/commands/issue/convert-to-plan.md`
- Likely code locations:
  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)

### Evidence (Existing vs Planned)

| Pointer | Status | Evidence (docs + TS) | Verify | Why |
|---|---|---|---|---|
| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |

## Execution Process

### Phase 1: Parse Arguments & Detect Source Type

- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
- Extract `<SOURCE>` (first non-flag token).
- Detect source type (priority order):
  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
  - directory containing `.workflow/.lite-plan/*/plan.json`
  - markdown file: `*.md`
  - json file: `*.json`
- Validate flag constraints:
  - `--supplement` requires `--issue`

### Phase 2: Extract Data Using Format-Specific Extractor

- Extractor: Lite-Plan
  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
- Extractor: Workflow Session
  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
- Extractor: Markdown (AI-Assisted via Gemini)
  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
  - Parse returned JSON (strip code fences if present).
- Extractor: JSON File
  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).

### Phase 3: Normalize Task IDs

- Normalize to `T1..Tn`.
- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.

### Phase 4: Resolve Issue (Create or Find)

- If `--issue <id>`:
  - Validate via CLI (e.g. `ccw issue status <id> --json`).
- Else:
  - Create/init a new issue via CLI (title/description derived from extracted data).

### Phase 5: Generate Solution

- Build the solution object:
  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
- If `--supplement`:
  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.

### Phase 6: Confirm & Persist

- If auto mode (`-y/--yes`): skip confirmation.
- Else:
  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
- Persist:
  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.

### Phase 7: Summary

- Print:
  - issue id
  - solution id
  - task count
  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)

## Error Handling

- Invalid args:
  - missing `<SOURCE>`
  - `--supplement` without `--issue`
- Source not found / unsupported type
- Parse errors:
  - invalid JSON in plan/session/task files
  - markdown-to-json extractor returns non-JSON
- CLI failures:
  - issue not found (`--issue`)
  - bind/update failures (must report clearly; avoid partial writes where possible)
- Guardrails:
  - do not edit issue/solution store files directly for operations that have a CLI equivalent

## Examples

```bash
# Convert lite-plan to new issue (auto-creates issue)
/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"

# Convert workflow session to existing issue
/issue:convert-to-plan WFS-auth-impl --issue GH-123

# Supplement existing solution with additional tasks
/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement

# Auto mode - skip confirmations
/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
```

apply_patch(auto_approved=true) exited 0 in 106ms:
Success. Updated the following files:
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

Plan update
Generated slash and agent outlines using the skill templates, including an evidence table with verifiable docs headings + TS anchors and correct Existing/Planned statuses.
  ‚úì Collect skill templates/quality gates + parse requirement doc for CMD-010
  ‚úì Locate verifiable docs headings and TS anchor strings for evidence tables
  ‚úì Draft spec.json + references.json (non-leaky, concise)
  ‚úì Generate generated-slash-outline.md + generated-agent-outline.md using templates
  ‚Üí Generate gap-report.md + fix-plan.md and ensure evidence tables cover all pointers
  ‚Ä¢ Run deterministic gate: node verify-evidence.js on gap-report and slash outline; iterate until pass
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Reviewing gap report fixes**

The gap report should suggest a minimal list of fixes. Since the output is just an outline, it might help to remove ambiguities and align it with the existing CLI create solution command. Alternatively, I could use `ccw issue solution <issue-id> --data ...` for creation instead of writing JSONL. I need to check the `issue.ts` file for the usage of `ccw issue solution`, especially the `--data` option and how to implement it effectively. I'll confirm by searching for "--data" in that function.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "issue solution" -Context 0,2 | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 327ms:
 * Create: ccw issue solution <issue-id> --data '{"tasks":[...]}'
 * Read:   ccw issue solution <issue-id> [--brief] [--solution-id <id>]
    console.error(chalk.gray('Usage: ccw issue solution <issue-id> [--brief] [--solution-id <id>]'));
    console.error(chalk.gray('       ccw issue solution <issue-id> --data \'{"tasks":[...]}\''));
 * Usage: ccw issue solutions --status planned --brief
  // Add issue solution to queue (solution-level granularity)
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+



thinking
**Refining outline for CLI usage**

I see that we can enhance our outline by specifying creation with `ccw issue solution <issue-id> --data '<json>'` instead of a direct write. The outline suggests using `ccw issue solution ...` when it's available, but I think we should clarify this to reduce ambiguity and stick to the principle of using the CLI for operations. As we update the outline for phase 6, we should ensure it prefers CLI for creation and binding. I'll also keep output files concise while ensuring our approach remains effective and aligned with the core data access principle.
thinking
**Identifying P0 for correctness**

I believe this is a P0 issue because it impacts the correctness of our approach. I need to put this in the gap report, emphasizing that our fix plan should instruct us to always use `ccw issue solution <issue-id> --data '<json>'`, including `--solution-id` for supplementary updates. However, I wonder if updating a supplement might need a separate command. I should check issue.ts for how `--solution-id` is used during writes to clarify this. Let's search for the "solution-id" string!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "solution-id" | Select-Object -First 30 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
  solutionId?: string;  // --solution-id <id> for filtering solutions
 * Read:   ccw issue solution <issue-id> [--brief] [--solution-id <id>]
    console.error(chalk.gray('Usage: ccw issue solution <issue-id> [--brief] [--solution-id <id>]'));
  // Filter by solution-id if specified
    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));
      console.error(chalk.gray('First bind a solution: ccw issue bind <issue-id> <solution-id>'));
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "--data" -Context 0,1 | Select-Object -First 50 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
 * Usage: ccw issue create --data '{"title":"...", "context":"..."}'
    console.error(chalk.gray('Usage: ccw issue create --data \'{"title":"...", "context":"..."}\''));
 * Create: ccw issue solution <issue-id> --data '{"tasks":[...]}'
    console.error(chalk.gray('       ccw issue solution <issue-id> --data \'{"tasks":[...]}\''));
  // CREATE mode: if --data provided
      console.log(chalk.gray('  create --data \'{"title":"..."}\'    Create issue (auto-generates ID)'));
      console.log(chalk.gray('  solution <id> --data \'{...}\'       Create solution (auto-generates ID)'));
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Inspecting implementation**

I need to check the solutionAction implementation to understand how the create function works. My first step is to use Select-String to find the phrase "CREATE mode: if --data provided" and gather context about that specific line. This will help me see how everything ties together within the code. I'm curious to find out more about this functionality and how it all operates!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
$match = Select-String -Path ccw/src/commands/issue.ts -Pattern "CREATE mode: if --data provided" -SimpleMatch | Select-Object -First 1; if ($match) { $start=[Math]::Max(0,$match.LineNumber-5); $end=$match.LineNumber+25; Get-Content ccw/src/commands/issue.ts | Select-Object -Index ($start..$end) }' in C:\Project\Claude-Code-Workflow succeeded in 351ms:
      // stdin not available or empty
    }
  }

  // CREATE mode: if --data provided
  if (jsonData) {
    try {
      const data = JSON.parse(jsonData);
      const solution = createSolution(issueId, data);
      console.log(JSON.stringify(solution, null, 2));
    } catch (err) {
      console.error(chalk.red((err as Error).message));
      process.exit(1);
    }
    return;
  }

  // READ mode: list solutions for issue
  const issue = findIssue(issueId);
  if (!issue) {
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..f9e4c8161609e1b6a70bc670e587cd91bbfb1a57
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,157 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+





thinking
**Optimizing CLI Outline**

I‚Äôm thinking we can enhance the outline by noting, "read existing solutions via CLI and write an updated combined solution list in JSONL." This might point to a gap in P1 updates. Our output will focus on the slash command documentation. However, since the slash command utilizes LLM and can execute `ccw issue solution`, we should avoid mentioning direct writes and emphasize CLI tasks instead. I‚Äôm curious if this will impact the evidence table since the pointer structure remains internal. Still, it looks fine overall!
thinking
**Updating the Outline**

I‚Äôm considering updating the generated slash outline to specify persistence via `ccw issue solution`, even though it‚Äôs not strictly required by the user. It could improve clarity. However, if we do this, there‚Äôs a concern that the evidence table pointer `.workflow/issues/solutions/<issue-id>.jsonl` might imply it‚Äôs "existing" when it doesn't actually exist in the repo. I should also update the execution process section to include explicit CLI calls in Phase 6. 

After we generate the gap report and fix plan, we need to verify evidence. It seems like we should incorporate any necessary fixes into the outline now instead of treating them as just suggestions.
thinking
**Adjusting the Process**

I‚Äôm thinking about the skill phases: we start with generating outlines, then create a gap report and iterate. So, if the gap report identifies any P0 gaps, we should adjust the outlines accordingly. While the user wants the evidence tables to pass, they didn‚Äôt specifically ask for an iteration process. However, it feels right to follow minimal iteration principles and close those P0 gaps.  

I think it‚Äôs best to patch the outline now to prioritize CLI persistence before we finalize the gap report. I just want to make sure we're on track!
thinking
**Patching the Outline**

I‚Äôm planning to update `generated-slash-outline.md` in Phase 6. I‚Äôll remove the phrase "Write/update ... (or use ccw issue solution ... if available)" and replace it with explicit steps. For instance, to create a solution, I‚Äôll specify using the command `ccw issue solution <issue-id> --data '<json>' --json`, noting that this prints JSON we can parse. 

I need to add instructions to bind the solution with `ccw issue bind <issue-id> <solution-id>` and update the status with `ccw issue update <issue-id> --status planned`. The outputs will continue to be produced by CLI as `.workflow/issues/solutions/<issue-id>.jsonl`, which is fine. I'll also ensure to mention that the CLI auto-generates certain elements.
file update
M C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -115,4 +115,6 @@
 - Persist:
-  - Write/update `.workflow/issues/solutions/<issue-id>.jsonl` (or use `ccw issue solution ...` if available for creation/update).
-  - Bind solution via `ccw issue bind <issue-id> <solution-id>` and set status to planned via `ccw issue update <issue-id> --status planned`.
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
 
@@ -156,2 +158 @@
 ```
-
apply_patch(auto_approved=true) exited 0 in 90ms:
Success. Updated the following files:
M .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Exploring solution creation options**

I‚Äôm considering the `--solution-id` option for creating a solution, but I‚Äôm unsure if it allows for a fixed ID. I think createSolution might auto-generate an ID, yet it could accept a provided one, which could overwrite existing entries. I can‚Äôt make assumptions, so I‚Äôll inspect the createSolution function to check for uniqueness or update capabilities. Let‚Äôs search for "function createSolution(" and see what it reveals!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "function createSolution" -Context 0,3 | Select-Object -First 20 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 323ms:
function createSolution(issueId: string, data: Partial<Solution>): Solution {
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Evaluating function access**

I'm thinking about how to access that function. Using Get-Content seems like a solid start, especially when I consider needing the context around the specific line number. That makes sense! So, I'll need to use Select-String with the pattern "function createSolution" to pinpoint the line number accurately. It feels like I'm on the right track here! Let‚Äôs see how that works out.
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
$match = Select-String -Path ccw/src/commands/issue.ts -Pattern "function createSolution'"\\(\" -SimpleMatch | Select-Object -First 1; "'$match.LineNumber' in C:\Project\Claude-Code-Workflow succeeded in 333ms:

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
I think there‚Äôs something not quite right with the output since it didn‚Äôt return anything. It might be related to the match variable or escaping issues causing difficulties. I wonder if simplifying my approach could help work through this. Let me think about breaking things down to ensure the problem can be identified. It's all about troubleshooting, right? I'll keep trying to find the solution!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
(Select-String -Path ccw/src/commands/issue.ts -Pattern "function createSolution" | Select-Object -First 1).LineNumber' in C:\Project\Claude-Code-Workflow succeeded in 327ms:
667
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content ccw/src/commands/issue.ts | Select-Object -Index (660..740)' in C:\Project\Claude-Code-Workflow succeeded in 331ms:
}

/**
 * Create a new solution with proper JSONL handling
 * Auto-generates ID if not provided
 */
function createSolution(issueId: string, data: Partial<Solution>): Solution {
  const issue = findIssue(issueId);
  if (!issue) {
    throw new Error(`Issue "${issueId}" not found`);
  }

  const solutions = readSolutions(issueId);
  const solutionId = data.id || generateSolutionId(issueId, solutions);

  if (solutions.some(s => s.id === solutionId)) {
    throw new Error(`Solution "${solutionId}" already exists`);
  }

  const newSolution: Solution = {
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Select-String -Path ccw/src/commands/issue.ts -Pattern "--solution" | Select-Object -First 50 | ForEach-Object { $_.Line }' in C:\Project\Claude-Code-Workflow succeeded in 321ms:
  solutionId?: string;  // --solution-id <id> for filtering solutions
 * Read:   ccw issue solution <issue-id> [--brief] [--solution-id <id>]
    console.error(chalk.gray('Usage: ccw issue solution <issue-id> [--brief] [--solution-id <id>]'));
    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));
      console.log(chalk.gray('Register one: ccw issue bind <issue-id> --solution <path>'));
      console.log(chalk.yellow('Deprecated: use "ccw issue bind <issue-id> --solution <path>"'));
      console.log(chalk.gray('  --solution <path>                  Solution JSON file'));
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
**Inspecting bindAction functionality**

I'm needing to examine the bindAction function to determine if it can register or update properly. I think I should look around its definition, which I suspect is near line 280. My plan is to find the exact line number for bindAction, so I‚Äôll use Select-String to search for the phrase `async function bindAction`. That should help me track down where it‚Äôs defined and how it works!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
(Select-String -Path ccw/src/commands/issue.ts -Pattern "async function bindAction" | Select-Object -First 1).LineNumber' in C:\Project\Claude-Code-Workflow succeeded in 316ms:
1888
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-Content ccw/src/commands/issue.ts | Select-Object -Index (1875..1995)' in C:\Project\Claude-Code-Workflow succeeded in 345ms:
    console.log(JSON.stringify({ success: true, issue_id: issueId, updates }));
  } else {
    console.log(chalk.green(`‚úì Issue "${issueId}" updated`));
    Object.entries(updates).forEach(([k, v]) => {
      console.log(chalk.gray(`  ${k}: ${v}`));
    });
  }
}

/**
 * bind - Register and/or bind a solution
 */
async function bindAction(issueId: string | undefined, solutionId: string | undefined, options: IssueOptions): Promise<void> {
  if (!issueId) {
    console.error(chalk.red('Issue ID is required'));
    console.error(chalk.gray('Usage: ccw issue bind <issue-id> [solution-id] [--solution <path>]'));
    process.exit(1);
  }

  const issue = findIssue(issueId);
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+






thinking
**Analyzing CLI Operations**

I‚Äôm noticing that the core data access principle suggests using CLI for issue or solution operations, but maybe it‚Äôs specific to "metadata" and binding. I think direct writes might still be valid for solutions. I wonder if the slash command can list and read solutions, but not update them. The plan doc supports writing a jsonl file directly, which makes me think that it‚Äôs acceptable for creating new solutions. However, I‚Äôll need to figure out how to handle updates correctly.
thinking
**Refining the Outline for CLI Use**

I think we need to stay focused and not diverge too much. Our outline feels like just a basic framework, so I‚Äôm considering using CLI commands for creation and direct writing for supplements if necessary. Looking at the convert-to-plan document, it seems we might load solutions using specific commands before updating the file. I think I can mention in phases that supplements should read existing solutions via CLI and update the appropriate JSONL file while maintaining the same ID. Let‚Äôs make sure this step is clear!
thinking
**Clarifying the Gap Report**

It seems like the gap report will need to address the P0 gap, focusing on clarifying the supplement persistence approach using the existing patterns in the repository. I‚Äôll refer to the "Solution Binding" section mentioned in the brainstorm session since it talks about appending to JSONL and updating bindings. The gaps include supplement update semantics as P0, additional validations as P1, and optional improvements like updating the documentation site as P2. For the evidence table, I want to make sure we include all key pointers consistently. Lastly, I need to set up a separate fix-plan.md containing a minimal list of steps for implementing the supplement.
thinking
**Drafting the Gap Report**

I've got to keep things concise as the user requested, so the fix-plan might just list items. I need to write both the gap report and fix plan using the Apply Patch method. It‚Äôs important to remember that verify-evidence will be run on the gap report and the slash outline, so I'll ensure the gap report includes a well-structured evidence table that passes verification. The table should have columns for Pointer, Status, Evidence, Verify, and Notes. I‚Äôll make sure to format each evidence cell properly and avoid any placeholders. Let's get started on drafting the gap report!
thinking
**Preparing the Gap Report and Fix Plan**

I'm outlining the structure for the gap report focused on the convert-to-plan issue. I‚Äôve identified key gaps, starting with P0, which involves clarifying how to update existing solutions and maintain consistent IDs without duplicates. P1 gaps include documenting CLI commands and adding JSON schema validation checkpoints. For P2, I‚Äôm thinking about a troubleshooting section for the Gemini extractor. The implementation pointers will emphasize using the appropriate CLI tools. I‚Äôll also draft the fix plan to align with the requirements and ensure it defines the supplement behavior effectively. Now, let's get started on creating the gap-report.md and fix-plan.md!
file update
A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
# Fix Plan: issue:convert-to-plan

## P0 (Must)

1) Define `--supplement` behavior precisely
- Scope: command implementation + doc update
- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
- Verify:
  - `ccw issue solutions --issue <id> --json`
  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`

2) Enforce persistence rules consistently
- Scope: command implementation
- Prefer:
  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
  - `ccw issue bind <issue-id> <solution-id>`
  - `ccw issue update <issue-id> --status planned`
- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.

## P1 (Should)

3) Strengthen source detection + validations
- Scope: command implementation
- Verify:
  - lite-plan: `Test-Path <dir>/plan.json`
  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`

4) Make CLI call sequence explicit in docs
- Scope: command doc update
- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).

## P2 (Optional)

5) Markdown extractor hardening
- Scope: command implementation
- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).

A C:\Project\Claude-Code-Workflow\.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
# Gap Report: issue:convert-to-plan

## Reference

- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)

## P0 Gaps (Must Fix)

- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).

## P1 Gaps (Should Fix)

- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.

## P2 Gaps (Optional)

- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).

## Implementation Pointers (Evidence)

| Pointer | Status | Evidence | Verify | Notes |
|---|---|---|---|---|
| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |

## Implementation Hints (Tooling/Server)

- Prefer the issue CLI for creation and binding:
  - create/init issue: `ccw issue init ...`
  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
  - bind: `ccw issue bind <issue-id> <solution-id>`
  - status: `ccw issue status <issue-id> --json`
- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.

## Proposed Fix Plan (Minimal)

See `fix-plan.md`.

apply_patch(auto_approved=true) exited 0 in 113ms:
Success. Updated the following files:
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
A .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md --file=.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md' in C:\Project\Claude-Code-Workflow succeeded in 345ms:
OK: evidence verification passed
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

Plan update
Deterministic evidence gate passed for both gap-report and generated slash outline.
  ‚úì Collect skill templates/quality gates + parse requirement doc for CMD-010
  ‚úì Locate verifiable docs headings and TS anchor strings for evidence tables
  ‚úì Draft spec.json + references.json (non-leaky, concise)
  ‚úì Generate generated-slash-outline.md + generated-agent-outline.md using templates
  ‚úì Generate gap-report.md + fix-plan.md and ensure evidence tables cover all pointers
  ‚úì Run deterministic gate: node verify-evidence.js on gap-report and slash outline; iterate until pass
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+


thinking
I'm ensuring that my output path includes all the necessary files: spec.json, references.json, generated-slash-outline.md, generated-agent-outline.md, gap-report.md, and fix-plan.md. I need to double-check everything is there before moving forward. It's crucial to have all these documents in order to ensure a smooth process. So, okay, let's make sure nothing is missing!
exec
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -Command '[Console]::InputEncoding  = [Text.UTF8Encoding]::new($false)
[Console]::OutputEncoding = [Text.UTF8Encoding]::new($false)
chcp 65001 > $null
Get-ChildItem .workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs | Select-Object Name' in C:\Project\Claude-Code-Workflow succeeded in 324ms:

[32;1mName[0m
[32;1m----[0m
fix-plan.md
gap-report.md
generated-agent-outline.md
generated-slash-outline.md
references.json
spec.json

file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

codex
Used skill `slash-command-outliner` (to generate CCW-aligned outlines + evidence-gated pointers from the requirement doc).

Wrote outputs to:
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md`
- `.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md`

Evidence gate:
- `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=.../gap-report.md --file=.../generated-slash-outline.md` ‚úÖ passed
file update:
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
new file mode 100644
index 0000000000000000000000000000000000000000..5b082fae1a59445f198fb1cea8766a07c258ff1a
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/fix-plan.md
@@ -0,0 +1,38 @@
+# Fix Plan: issue:convert-to-plan
+
+## P0 (Must)
+
+1) Define `--supplement` behavior precisely
+- Scope: command implementation + doc update
+- Decision: update-in-place (preserve existing solution ID) vs create-new-and-rebind (new ID).
+- Verify:
+  - `ccw issue solutions --issue <id> --json`
+  - `ccw issue solution <issue-id> --solution-id <sol-id> --json`
+
+2) Enforce persistence rules consistently
+- Scope: command implementation
+- Prefer:
+  - `ccw issue solution <issue-id> --data '<solution-json>' --json`
+  - `ccw issue bind <issue-id> <solution-id>`
+  - `ccw issue update <issue-id> --status planned`
+- Only if supplement requires in-place edits: rewrite `.workflow/issues/solutions/<issue-id>.jsonl` once, then re-validate by reading via CLI.
+
+## P1 (Should)
+
+3) Strengthen source detection + validations
+- Scope: command implementation
+- Verify:
+  - lite-plan: `Test-Path <dir>/plan.json`
+  - session: `Test-Path .workflow/active/<WFS>/workflow-session.json`
+  - task glob: `rg \"IMPL-\" .workflow/active/<WFS>/.task/`
+
+4) Make CLI call sequence explicit in docs
+- Scope: command doc update
+- Include the exact `ccw issue` commands used in each mode (new issue vs existing issue; supplement vs new).
+
+## P2 (Optional)
+
+5) Markdown extractor hardening
+- Scope: command implementation
+- Add a single retry path on non-JSON output + show a minimal error snippet to the user (no secrets).
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
new file mode 100644
index 0000000000000000000000000000000000000000..51378d474e0ebd74d71365fdb1fc3a527f83e678
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/gap-report.md
@@ -0,0 +1,45 @@
+# Gap Report: issue:convert-to-plan
+
+## Reference
+
+- Selected reference: /issue:from-brainstorm (`.claude/commands/issue/from-brainstorm.md`)
+
+## P0 Gaps (Must Fix)
+
+- Supplement semantics: explicitly define how `--supplement` updates an existing solution without creating duplicate IDs (in-place update vs create-new-and-rebind).
+- Persistence path: ensure the implementation consistently uses the issue CLI for creation/binding, and only falls back to direct JSONL edits when there is no CLI support (document the exception clearly).
+
+## P1 Gaps (Should Fix)
+
+- Add concrete CLI call sequence per mode (create issue vs existing issue) so the implementation stays aligned with the Core Data Access Principle.
+- Tighten source detection/validation (directory vs file path; WFS id vs folder path; required file presence checks) with clear error messages.
+
+## P2 Gaps (Optional)
+
+- Add a small, deterministic fallback for markdown extraction failures (e.g., ask user to confirm/trim inputs, then retry once).
+
+## Implementation Pointers (Evidence)
+
+| Pointer | Status | Evidence | Verify | Notes |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | primary command doc and command discovery |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command listing surface used by CCW UI/server |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | authoritative CLI for issue/solution ops |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | source-of-truth schema shape for normalized output |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime directory created on demand |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue (CLI-backed) |
+
+## Implementation Hints (Tooling/Server)
+
+- Prefer the issue CLI for creation and binding:
+  - create/init issue: `ccw issue init ...`
+  - create solution: `ccw issue solution <issue-id> --data '<json>' --json`
+  - bind: `ccw issue bind <issue-id> <solution-id>`
+  - status: `ccw issue status <issue-id> --json`
+- For supplement, if no CLI update exists, plan for a single-file rewrite of `.workflow/issues/solutions/<issue-id>.jsonl` with strict ID preservation and immediate validation by re-reading via `ccw issue solution ...`.
+
+## Proposed Fix Plan (Minimal)
+
+See `fix-plan.md`.
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..d7c7aec05f2779d3123b3c25f4bb0fc468bab99f
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-agent-outline.md
@@ -0,0 +1,39 @@
+# Agent Outline: issue:convert-to-plan
+
+## Purpose
+
+Implement and/or evolve `/issue:convert-to-plan` to convert upstream planning artifacts into a normalized Solution and bind it to an issue via CCW CLI conventions.
+
+## Execution Model
+
+- Default: incremental, testable changes (one behavior slice at a time: arg parsing -> extractors -> persistence -> binding)
+- Pattern-first: use repo references (especially `/issue:from-brainstorm`) before introducing new abstractions
+- Confirmation-first: auto mode only when `-y/--yes` is present
+
+## State & Artifacts
+
+- Inputs:
+  - lite-plan: `.workflow/.lite-plan/**/plan.json`
+  - workflow sessions: `.workflow/active/WFS-*/` (metadata + `.task/IMPL-*.json`)
+  - markdown/json sources: `<SOURCE>.md` / `<SOURCE>.json`
+- Outputs:
+  - `.workflow/issues/solutions/<issue-id>.jsonl`
+  - issue/solution binding via `ccw issue bind` + status update via `ccw issue update`
+
+## Tooling
+
+- Allowed tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+- Non-negotiables:
+  - do not directly edit issue stores for operations that have a CLI equivalent
+  - no unrelated changes outside the command implementation
+  - keep evidence-based pointers (Existing vs Planned) accurate
+
+## Validation Strategy
+
+- P0 gates:
+  - frontmatter + allowed-tools + core sections + no broken artifact references
+  - evidence table passes: `node .codex/skills/slash-command-outliner/scripts/verify-evidence.js --file=<md>`
+- Behavioral checks:
+  - one example per source type + supplement + auto mode
+  - error paths: missing source, bad json, unknown session, CLI failure surfaces clean message
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
new file mode 100644
index 0000000000000000000000000000000000000000..8c726b2cf941ce0e679f8bbc1a3811606fdbb7fc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/generated-slash-outline.md
@@ -0,0 +1,158 @@
+---
+name: convert-to-plan
+description: Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions
+argument-hint: "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>"
+allowed-tools: TodoWrite(*), Bash(*), Read(*), Write(*), Glob(*), AskUserQuestion(*)
+group: issue
+---
+
+# Issue Convert-to-Plan Command (/issue:convert-to-plan)
+
+## Overview
+
+- Goal: Convert an existing planning artifact into a normalized issue Solution and bind it to an issue.
+- Command: `/issue:convert-to-plan`
+
+## Usage
+
+```bash
+/issue:convert-to-plan [-y|--yes] [--issue <id>] [--supplement] <SOURCE>
+```
+
+## Inputs
+
+- Required inputs:
+  - `<SOURCE>`: planning artifact path or a workflow session ID (`WFS-*`)
+- Optional inputs:
+  - `--issue <id>`: bind to an existing issue (otherwise auto-create)
+  - `--supplement`: add tasks to an existing solution (requires `--issue`)
+  - `-y, --yes`: skip confirmations (auto mode)
+
+## Outputs / Artifacts
+
+- Writes:
+  - `.workflow/issues/solutions/<issue-id>.jsonl` (solution list for an issue; creates directory if needed)
+- Reads:
+  - `.workflow/.lite-plan/**/plan.json`
+  - `.workflow/active/WFS-*/workflow-session.json`
+  - `.workflow/active/WFS-*/IMPL_PLAN.md` (optional)
+  - `.workflow/active/WFS-*/.task/IMPL-*.json`
+  - `<SOURCE>.md` / `<SOURCE>.json`
+  - `.claude/workflows/cli-templates/schemas/solution-schema.json` (target schema)
+
+## Implementation Pointers
+
+- Command doc: `.claude/commands/issue/convert-to-plan.md`
+- Likely code locations:
+  - `ccw/src/commands/issue.ts` (issue CLI: status/init/solution(s)/bind/update)
+  - `ccw/src/core/routes/issue-routes.ts` (bind side effects)
+  - `ccw/src/core/routes/commands-routes.ts` (command doc discovery/listing)
+
+### Evidence (Existing vs Planned)
+
+| Pointer | Status | Evidence (docs + TS) | Verify | Why |
+|---|---|---|---|---|
+| `.claude/commands/issue/convert-to-plan.md` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path .claude/commands/issue/convert-to-plan.md; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | command doc source (and how commands are discovered) |
+| `ccw/src/core/routes/commands-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Overview ; ts: `ccw/src/core/routes/commands-routes.ts` / function scanCommandsRecursive( | `Test-Path ccw/src/core/routes/commands-routes.ts; rg \"function scanCommandsRecursive\" ccw/src/core/routes/commands-routes.ts` | server route that enumerates command docs |
+| `ccw/src/commands/issue.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/commands/issue.ts` / async function bindAction( | `Test-Path ccw/src/commands/issue.ts; rg \"async function bindAction\" ccw/src/commands/issue.ts` | issue/solution CLI operations used by this command |
+| `ccw/src/core/routes/issue-routes.ts` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Core Data Access Principle ; ts: `ccw/src/core/routes/issue-routes.ts` / function bindSolutionToIssue( | `Test-Path ccw/src/core/routes/issue-routes.ts; rg \"function bindSolutionToIssue\" ccw/src/core/routes/issue-routes.ts` | binding behavior + status side effects |
+| `.claude/workflows/cli-templates/schemas/solution-schema.json` | Existing | docs: `.claude/commands/issue/convert-to-plan.md` / Solution Schema Reference ; ts: `ccw/src/commands/issue.ts` / bound_solution_id | `Test-Path .claude/workflows/cli-templates/schemas/solution-schema.json; rg \"bound_solution_id\" ccw/src/commands/issue.ts` | target solution shape and required fields |
+| `.workflow/issues/solutions` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 6: Confirm & Persist ; ts: `ccw/src/commands/issue.ts` / .workflow/issues/solutions | `Test-Path .workflow/issues/solutions; rg \"\\.workflow/issues/solutions\" ccw/src/commands/issue.ts` | runtime output directory (not committed) |
+| `.workflow/issues/solutions/<issue-id>.jsonl` | Planned | docs: `.claude/commands/issue/convert-to-plan.md` / Phase 5: Generate Solution ; ts: `ccw/src/commands/issue.ts` / export function writeSolutions( | `rg \"export function writeSolutions\" ccw/src/commands/issue.ts` | persisted solutions per issue |
+
+## Execution Process
+
+### Phase 1: Parse Arguments & Detect Source Type
+
+- Parse flags: `--issue`, `--supplement`, `-y/--yes`.
+- Extract `<SOURCE>` (first non-flag token).
+- Detect source type (priority order):
+  - workflow session ID: `WFS-*` -> `.workflow/active/<id>/`
+  - directory containing `.workflow/.lite-plan/*/plan.json`
+  - markdown file: `*.md`
+  - json file: `*.json`
+- Validate flag constraints:
+  - `--supplement` requires `--issue`
+
+### Phase 2: Extract Data Using Format-Specific Extractor
+
+- Extractor: Lite-Plan
+  - Read `<SOURCE>/plan.json` (or resolved plan.json) and map to Solution fields.
+- Extractor: Workflow Session
+  - Read `workflow-session.json` and task JSONs from `.task/IMPL-*.json`.
+  - Optionally read `IMPL_PLAN.md` for approach/strategy text.
+- Extractor: Markdown (AI-Assisted via Gemini)
+  - Read markdown file content and invoke a deterministic CLI wrapper (e.g. `ccw cli ... --tool gemini`) to return JSON matching solution schema.
+  - Parse returned JSON (strip code fences if present).
+- Extractor: JSON File
+  - Parse JSON and normalize to the Solution schema (pass-through if already solution-shaped).
+
+### Phase 3: Normalize Task IDs
+
+- Normalize to `T1..Tn`.
+- Map common patterns (e.g. `IMPL-001` -> `T1`) and preserve ordering.
+
+### Phase 4: Resolve Issue (Create or Find)
+
+- If `--issue <id>`:
+  - Validate via CLI (e.g. `ccw issue status <id> --json`).
+- Else:
+  - Create/init a new issue via CLI (title/description derived from extracted data).
+
+### Phase 5: Generate Solution
+
+- Build the solution object:
+  - `id`: `SOL-<issue-id>-<uid>` (or defer to CLI if it auto-generates)
+  - `description`, `approach`, `tasks[]`, timestamps, binding metadata
+- If `--supplement`:
+  - Load existing solution(s) via CLI, merge/append tasks, and keep IDs normalized.
+
+### Phase 6: Confirm & Persist
+
+- If auto mode (`-y/--yes`): skip confirmation.
+- Else:
+  - Show a brief conversion summary (issue target + task count + first few task titles) and confirm.
+- Persist:
+  - Create solution via CLI (preferred):
+    - `ccw issue solution <issue-id> --data '<solution-json>' --json` (capture returned `id`)
+  - Bind solution via `ccw issue bind <issue-id> <solution-id>`
+  - Set status to planned via `ccw issue update <issue-id> --status planned`
+
+### Phase 7: Summary
+
+- Print:
+  - issue id
+  - solution id
+  - task count
+  - suggested next commands (e.g. `/issue:queue`, `ccw issue solution <id> --brief`)
+
+## Error Handling
+
+- Invalid args:
+  - missing `<SOURCE>`
+  - `--supplement` without `--issue`
+- Source not found / unsupported type
+- Parse errors:
+  - invalid JSON in plan/session/task files
+  - markdown-to-json extractor returns non-JSON
+- CLI failures:
+  - issue not found (`--issue`)
+  - bind/update failures (must report clearly; avoid partial writes where possible)
+- Guardrails:
+  - do not edit issue/solution store files directly for operations that have a CLI equivalent
+
+## Examples
+
+```bash
+# Convert lite-plan to new issue (auto-creates issue)
+/issue:convert-to-plan ".workflow/.lite-plan/implement-auth-2026-01-25"
+
+# Convert workflow session to existing issue
+/issue:convert-to-plan WFS-auth-impl --issue GH-123
+
+# Supplement existing solution with additional tasks
+/issue:convert-to-plan "./docs/additional-tasks.md" --issue ISS-001 --supplement
+
+# Auto mode - skip confirmations
+/issue:convert-to-plan ".workflow/.lite-plan/my-plan" -y
+```
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
new file mode 100644
index 0000000000000000000000000000000000000000..b193ff0e08143dc65b62522d506fa6b712ab79aa
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/references.json
@@ -0,0 +1,40 @@
+{
+  "candidates": [
+    {
+      "slash": "/issue:from-brainstorm",
+      "file_path": ".claude/commands/issue/from-brainstorm.md",
+      "score": 0.95,
+      "why": "Same group (issue). Produces Solution schema, supports auto-mode, and performs CLI-based issue creation + solution binding."
+    },
+    {
+      "slash": "/issue:plan",
+      "file_path": ".claude/commands/issue/plan.md",
+      "score": 0.78,
+      "why": "Issue planning workflow; overlaps in solution lifecycle and binding semantics."
+    },
+    {
+      "slash": "/issue:discover-by-prompt",
+      "file_path": ".claude/commands/issue/discover-by-prompt.md",
+      "score": 0.72,
+      "why": "Converts free-form input into structured issue artifacts; similar interaction model (confirm/persist) and Gemini usage patterns."
+    },
+    {
+      "slash": "/workflow:lite-execute",
+      "file_path": ".claude/commands/workflow/lite-execute.md",
+      "score": 0.62,
+      "why": "Reads lite-plan plan.json and follows task/acceptance structure; useful for plan.json shape and validations."
+    },
+    {
+      "slash": "/workflow:plan-verify",
+      "file_path": ".claude/commands/workflow/plan-verify.md",
+      "score": 0.55,
+      "why": "Validates plan/task artifacts and provides a verification checklist; useful for conversion sanity checks."
+    }
+  ],
+  "selected": {
+    "slash": "/issue:from-brainstorm",
+    "file_path": ".claude/commands/issue/from-brainstorm.md",
+    "why": "Closest match: turns an upstream artifact into issue + bound solution with auto/interactive modes and CLI integration."
+  }
+}
+
diff --git a/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
new file mode 100644
index 0000000000000000000000000000000000000000..b611bba22fde07aed1711cf0fc8808fe3965d9cc
--- /dev/null
+++ b/.workflow/.cycle/cycle-auto-20260205T010617-slashcmdoutliner-codex.progress/llm/CMD-010/specs/outputs/spec.json
@@ -0,0 +1,55 @@
+{
+  "command": {
+    "group": "issue",
+    "name": "convert-to-plan",
+    "description": "Convert planning artifacts (lite-plan, workflow session, markdown) to issue solutions",
+    "argument_hint": "[-y|--yes] [--issue <id>] [--supplement] <SOURCE>",
+    "allowed_tools": [
+      "TodoWrite(*)",
+      "Bash(*)",
+      "Read(*)",
+      "Write(*)",
+      "Glob(*)",
+      "AskUserQuestion(*)"
+    ]
+  },
+  "intent": {
+    "type": "plan",
+    "interaction": "iterative",
+    "primary_user_value": "Turn an existing planning artifact into a normalized issue Solution and bind it to an issue (create new or attach to an existing issue)."
+  },
+  "artifacts": {
+    "reads": [
+      ".workflow/.lite-plan/**/plan.json",
+      ".workflow/active/WFS-*/workflow-session.json",
+      ".workflow/active/WFS-*/IMPL_PLAN.md",
+      ".workflow/active/WFS-*/.task/IMPL-*.json",
+      "<SOURCE>.md",
+      "<SOURCE>.json",
+      ".claude/workflows/cli-templates/schemas/solution-schema.json"
+    ],
+    "writes": [
+      ".workflow/issues/solutions",
+      ".workflow/issues/solutions/<issue-id>.jsonl"
+    ]
+  },
+  "constraints": {
+    "max_rounds": 2,
+    "time_budget_seconds": 180,
+    "must_not": [
+      "Do not read or edit .workflow/issues/*.jsonl directly for issue/solution operations; use ccw issue CLI commands.",
+      "Do not skip confirmation unless -y/--yes is provided.",
+      "Do not claim implementation pointers are Existing unless they are verifiable in the repo."
+    ]
+  },
+  "acceptance": {
+    "p0": [
+      "Frontmatter includes name/description/argument-hint/allowed-tools",
+      "Supports sources: lite-plan dir, workflow session ID/folder, markdown file, json file",
+      "Implements flags: --issue, --supplement, -y/--yes",
+      "Persists a Solution in .workflow/issues/solutions/<issue-id>.jsonl and binds it to the issue via CLI",
+      "Uses ccw issue CLI (status/init/bind/solutions/solution) for issue operations"
+    ]
+  }
+}
+

tokens used
110,805
