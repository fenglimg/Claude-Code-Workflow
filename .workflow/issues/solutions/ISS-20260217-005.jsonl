{"id":"SOL-ISS-20260217-005-m9p2","description":"撰写 CCW 深度研习文档 Chapter 10.6，分析 TS 与 Python 跨语言 JSON-RPC 序列化机制，重点关注类型损耗与精度问题","approach":"基于 OUTLINE.md 中定义的 Chapter 10.6 结构，分析 cli-output-converter.ts 中的 JSON 解析逻辑，创建类型损耗分析表（TS → JSON → Python），记录 BigInt 精度问题和类型走私案事故复盘。","tasks":[{"id":"T1","title":"创建 JSON 序列化类型损耗分析表","scope":"docs/deep-study/part4-5-cross-language","action":"Create","description":"分析并记录 TS 类型经过 JSON 序列化后在 Python 端的类型变化，标注损耗程度","files":[{"path":"docs/deep-study/part4-5-cross-language/10.6-json-rpc-border.md","action":"create","change":"创建新文件，包含类型损耗分析表"}],"implementation":["分析 JSON.stringify() 对 TS 类型的转换行为","记录 BigInt → string 精度问题 (Number.MAX_SAFE_INTEGER)","记录 Date → string (ISO 8601) 可恢复","记录 Map → object 键类型丢失","记录 Set → array 唯一性丢失","记录 undefined → (缺失) 可映射到 None"],"test":{"commands":["node -e \"console.log(JSON.stringify({big: 9007199254740993n, date: new Date(), map: new Map([[1,'a']]), set: new Set([1,2,2])}))\""],"manual_checks":["验证类型转换表与实际行为一致"]},"convergence":{"criteria":["至少 6 种类型的损耗分析","每种类型标注损耗等级 (可恢复/部分丢失/完全丢失)","提供 Python 端恢复策略建议"],"verification":"技术审校确认类型分析准确性"},"commit":{"type":"docs","scope":"deep-study","message_template":"docs(deep-study): create Chapter 10.6 JSON-RPC serialization border"},"depends_on":[],"priority":"high"},{"id":"T2","title":"分析 cli-output-converter.ts JSON 解析逻辑","scope":"docs/deep-study/part4-5-cross-language","action":"Add","description":"深入分析 JsonLinesParser 类的缓冲区管理、流式解析、错误恢复机制","files":[{"path":"docs/deep-study/part4-5-cross-language/10.6-json-rpc-border.md","action":"modify","target":"第二幕：思维脉络","change":"添加 JSON Lines 解析器架构分析"}],"implementation":["分析 JsonLinesParser.buffer 的行缓冲机制","记录 parse() 方法中的跨 chunk 行处理逻辑","分析 classifyNonJsonContent() 的错误分类策略","记录 flush() 方法的剩余缓冲区处理","绘制 JSON 流解析状态机图"],"test":{"commands":["grep -n 'class JsonLinesParser' ccw/src/tools/cli-output-converter.ts"],"manual_checks":["验证解析逻辑与源码一致"]},"convergence":{"criteria":["缓冲区管理机制清晰说明","跨 chunk 行处理逻辑准确","错误分类策略完整记录"],"verification":"源码对照验证"},"commit":null,"depends_on":["T1"],"priority":"medium"},{"id":"T3","title":"撰写 BigInt 精度问题与类型走私案","scope":"docs/deep-study/part4-5-cross-language","action":"Add","description":"记录 BigInt 超过 MAX_SAFE_INTEGER 的精度丢失问题，撰写类型走私案事故复盘（OUTLINE.md 第351-395行）","files":[{"path":"docs/deep-study/part4-5-cross-language/10.6-json-rpc-border.md","action":"modify","target":"事故复盘档案 #10.6","change":"添加类型走私案完整记录"}],"implementation":["复述 OUTLINE.md 中的类型走私案：交易 ID 9007199254740993 精度丢失","分析根因：json-bigint 与原生 JSON.parse 混用","记录修复措施：统一使用 json-bigint，Schema 层强制 id 为 string","添加幽灵旁白：类型是第一个被搜身的旅客"],"test":{"manual_checks":["事故复盘格式与 OUTLINE.md 一致"]},"convergence":{"criteria":["事故场景完整复述","根因分析准确","修复措施可执行","幽灵旁白符合叙事风格"],"verification":"Review 事故档案完整性"},"commit":null,"depends_on":["T1"],"priority":"medium"},{"id":"T4","title":"撰写 stdio 缓冲区管理与 MCP 协议层","scope":"docs/deep-study/part4-5-cross-language","action":"Add","description":"分析 stdio 缓冲区管理策略，消息边界界定（\\\\n 分隔 vs 长度前缀），流式响应分块处理","files":[{"path":"docs/deep-study/part4-5-cross-language/10.6-json-rpc-border.md","action":"modify","target":"第二幕：思维脉络 - MCP 协议层","change":"添加 stdio 缓冲区管理章节"}],"implementation":["分析 \\\\n 作为消息边界的海关印章机制","对比长度前缀方案 (Content-Length header) 的优缺点","记录 PYTHONUNBUFFERED=1 的禁用缓冲配置","绘制 stdio 双向通信流程图"],"test":{"manual_checks":["验证缓冲区策略与实际实现一致"]},"convergence":{"criteria":["消息边界机制清晰","缓冲区配置说明完整","流式响应处理方案准确"],"verification":"技术审校确认"},"commit":null,"depends_on":["T1"],"priority":"medium"},{"id":"T5","title":"添加资产证言与架构陷阱","scope":"docs/deep-study/part4-5-cross-language","action":"Add","description":"撰写 JSON.stringify() 的第一人称资产证言，添加架构陷阱：为什么不用 Base64 编码所有数据？","files":[{"path":"docs/deep-study/part4-5-cross-language/10.6-json-rpc-border.md","action":"modify","target":"0. 资产证言 + 苏格拉底式思考","change":"添加资产证言和架构陷阱"}],"implementation":["撰写 JSON.stringify() 证言：'我是边境翻译官...我见过无数次类型失踪案...BigInt 是我最头疼的客户'","添加陷阱：为什么不用 Base64？揭示：33% 膨胀、内存翻倍、搜索失效、调试困难","添加调查进度条和幽灵位置标注"],"test":{"manual_checks":["证言风格与现有章节一致"]},"convergence":{"criteria":["资产证言符合小说化风格","架构陷阱有揭示部分","幽灵追踪进度条准确"],"verification":"风格审校确认"},"commit":null,"depends_on":["T1"],"priority":"low"}],"exploration_context":{"relevant_files":["ccw/src/tools/cli-output-converter.ts","ccw/src/tools/cli-executor-core.ts","codex-lens/src/codexlens/api/","docs/deep-study/OUTLINE.md"],"patterns":"JSON序列化 → 类型损耗 → BigInt精度 → stdio缓冲 → MCP协议","integration_points":"cli-output-converter.ts 的 JsonLinesParser 与 spawn() 的 stdout 管道对接"},"analysis":{"risk":"low","impact":"medium","complexity":"medium"},"score":0.89,"is_bound":true,"bound_at":"2026-02-17T14:12:02.295Z"}
