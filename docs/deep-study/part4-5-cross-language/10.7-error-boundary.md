# Chapter 10.7: 错误边界与故障恢复 (Error Boundary & Recovery)

> **生命周期阶段**: 错误捕获 -> 错误转换 -> 错误传递 -> 恢复策略
> **版本追踪**: `docs/.audit-manifest.json`
> **阅读时间**: 40-55 分钟
> **版本**: v1.0 (初版)
> **依赖章节**: [Chapter 10.5: 外交官与间谍](./10.5-child-process-diplomat.md)

---

## 0. 资产证言 (Asset Testimony)

> *"我是 `stderr`。人们叫我间谍通道。"*
>
> *"我见过无数秘密被泄露。Python 的堆栈追踪、调试日志、警告信息，都从我这里流过。但我的缓冲区一旦满了，信使就会失踪。"*
>
> *"我记录着 Python 端的每一次崩溃：`ValueError` 在参数验证时尖叫，`ImportError` 在找不到模块时哭泣，`KeyboardInterrupt` 在用户按 Ctrl+C 时沉默离去。这些异常在 Python 端是活生生的对象，但到了我这里，都变成了字符串。"*
>
> *"TypeScript 端的 `errorLog()` 函数是我的档案管理员。她把我的内容分类、打标签，有时候截断到 2048 字节——'为了性能'，她说。但那些被截断的堆栈信息，谁来负责？"*
>
> *"...最近，我注意到一个幽灵。当一个未捕获的 Python 异常级联发生时，我的缓冲区开始膨胀，进程进入假死状态，然后——OOM Killer 来敲门。"*

```markdown
调查进度: ██████████ 60%
幽灵位置: 错误边界层 - Python 未捕获异常导致 stderr 缓冲区溢出
本章线索: 当 Python 异常未被 try/except 捕获时，stderr 输出可能超过缓冲区限制
           └── 可能的根因: 大型 traceback 输出 + stderr 监听器未及时 drain
           └── 级联后果: 子进程 BLOCKED -> 父进程等待超时 -> 内存累积
```

---

## 苏格拉底式思考

> **架构生死战 10.7**: Python 子进程抛出了一个未捕获的异常。TypeScript 需要知道发生了什么。但是：
> - Python 异常对象无法直接序列化为 JSON
> - 堆栈信息在 stderr 中，格式不统一
> - 错误码映射不完整（exit code 可能是 1, 137, 或其他）
>
> 你会设计怎样的"错误边界"？每种选择都会牺牲一些东西 - 信息完整性？处理速度？用户体验？

---

> **架构陷阱 10.7.1**: 为什么不让 Python 异常直接冒泡到 TypeScript？
>
> **陷阱方案**: 把 Python 异常堆栈原封不动地传递给 TypeScript，让调用方自己解析。
>
> <details>
> <summary>**揭示陷阱**</summary>
>
> **跨语言异常的不可逾越之墙**:
>
> ```python
> # Python 端的异常
> def process_data(data):
>     return json.loads(data)  # json.JSONDecodeError
>
> # 堆栈追踪 (通过 stderr):
> # Traceback (most recent call last):
> #   File "cli.py", line 42, in <module>
> #     result = process_data(malformed_input)
> #   File "cli.py", line 38, in process_data
> #     return json.loads(data)
> #   File "/usr/lib/python3.10/json/__init__.py", line 346, in loads
> #     return _default_decoder.decode(s)
> # json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
> ```
>
> ```typescript
> // TypeScript 收到的只是字符串
> // 问题 1: 无法获取异常类型
> // 问题 2: 无法获取结构化的错误上下文
> // 问题 3: 堆栈信息是 Python 路径，与 TS 代码无关
>
> // 陷阱方案: 直接传递字符串
> function handlePythonError(stderr: string) {
>   throw new Error(stderr);  // 丢失所有结构化信息
> }
> ```
>
> **设计哲学**:
> > *"跨语言异常就像试图用英语解释中文的意境。你可以翻译字面意思，但韵味、语气、文化背景都会丢失。"*
>
> **正确设计: 错误映射表**
>
> ```typescript
> // 定义 Python 异常到 TS 错误的映射
> const ERROR_MAPPING = {
>   'ValueError': { tsType: 'TypeError', strategy: '参数验证失败' },
>   'FileNotFoundError': { tsType: 'ENOENT', strategy: '检查文件路径' },
>   'ImportError': { tsType: 'DependencyError', strategy: '环境诊断' },
>   'KeyboardInterrupt': { tsType: 'AbortError', strategy: '清理退出' },
>   'JSONDecodeError': { tsType: 'ParseError', strategy: '输入格式检查' },
> };
>
> function mapPythonError(stderr: string): Error {
>   const errorType = detectPythonErrorType(stderr);
>   const mapping = ERROR_MAPPING[errorType] || { tsType: 'CliExecutionError', strategy: '原始信息保留' };
>   return new CliExecutionError(stderr, mapping);
> }
> ```
>
> </details>

---

> **架构陷阱 10.7.2**: 为什么 stderr 内容要截断？
>
> **陷阱方案**: 保留完整的 stderr 内容，不截断。
>
> <details>
> <summary>**揭示陷阱**</summary>
>
> **内存与信息的权衡**:
>
> ```typescript
> // 当前实现: 截断到 2048 字节
> const execution: ExecutionRecord = {
>   output: {
>     stdout: stdout.substring(0, 10240),  // 10KB
>     stderr: stderr.substring(0, 2048),   // 2KB
>     truncated: stdout.length > 10240 || stderr.length > 2048
>   }
> };
>
> // 问题场景: Python 大型 traceback
> // - 循环引用导致无限堆栈打印
> // - 递归深度超过 1000 层
> // - 包含大型数据结构的 repr()
> // 结果: stderr 可能达到 MB 级别
> ```
>
> **幽灵线索: 截断掩盖了真相**
>
> ```python
> # 完整的 stderr (被截断前)
> Traceback (most recent call last):
>   File "cli.py", line 42, in <module>
>     result = recursive_process(data)
>   ...
>   File "cli.py", line 15, in recursive_process
>     return recursive_process(data)
> RecursionError: maximum recursion depth exceeded
> 
> # 关键信息在末尾: RecursionError
> # 但如果截断发生在中间，关键信息丢失
> ```
>
> **改进策略**:
> ```typescript
> // 智能截断: 保留头部和尾部
> function smartTruncate(text: string, maxSize: number): string {
>   if (text.length <= maxSize) return text;
>   const headSize = Math.floor(maxSize * 0.6);
>   const tailSize = maxSize - headSize - 20;
>   return text.slice(0, headSize) + 
>          '\n... [truncated] ...\n' + 
>          text.slice(-tailSize);
> }
> ```
>
> </details>

---

## 第一幕: Python 异常到 TS 错误映射表

### 错误类型映射

基于 `cli-executor-core.ts` 和 `cli-executor-utils.ts` 的错误处理逻辑，我们建立以下映射关系:

| Python 异常 | TS 错误 | 处理策略 | 触发条件 |
|-------------|---------|----------|----------|
| `ValueError` | `TypeError` | 参数验证失败 | 参数类型/格式不匹配 |
| `FileNotFoundError` | `ENOENT` | 文件检查 | 文件/目录不存在 |
| `ImportError` / `ModuleNotFoundError` | `DependencyError` | 环境诊断 | 缺少依赖包 |
| `KeyboardInterrupt` | `AbortError` | 清理退出 | 用户 Ctrl+C |
| `json.JSONDecodeError` | `ParseError` | 输入格式检查 | JSON 解析失败 |
| `PermissionError` | `EACCES` | 权限检查 | 文件/目录权限不足 |
| `TimeoutError` | `TimeoutError` | 超时处理 | 操作超时 |
| 自定义异常 | `CliExecutionError` | 原始信息保留 | 未知异常类型 |

### JSON-RPC 错误码

CLI 封装 endpoint 可能返回的 JSON-RPC 标准错误码:

| 错误码 | 名称 | 描述 | 处理方式 |
|--------|------|------|----------|
| `-32700` | Parse error | JSON 解析失败 | 检查输入格式 |
| `-32600` | Invalid Request | 请求对象无效 | 检查参数结构 |
| `-32601` | Method not found | 方法不存在 | 检查 API 路由 |
| `-32602` | Invalid params | 参数无效 | 参数验证失败 |
| `-32603` | Internal error | 内部错误 | 查看详细日志 |
| `-32000` | Server error | 服务器错误 | 重试或降级 |

### 致命错误检测

```typescript
// 来源: cli-executor-core.ts:294-296, 1064-1067
const hasFatalError = stderr.includes('FATAL') ||
                      stderr.includes('Authentication failed') ||
                      stderr.includes('API key') ||
                      stderr.includes('rate limit exceeded');
```

**致命错误分类**:

| 关键词 | 含义 | 恢复策略 |
|--------|------|----------|
| `FATAL` | 不可恢复错误 | 终止执行 |
| `Authentication failed` | 认证失败 | 检查 API key 配置 |
| `API key` | API key 问题 | 检查环境变量 |
| `rate limit exceeded` | 速率限制 | 指数退避重试 |

---

## 第二幕: 错误处理流程

### 进程错误处理状态机

```
                    ┌──────────────────────────────────────────────────────────┐
                    │                    child.on('close')                     │
                    │                                                          │
                    ▼                                                          │
             ┌─────────────┐                                                   │
             │  code !== 0 │                                                   │
             └──────┬──────┘                                                   │
                    │                                                          │
         ┌──────────┴──────────┐                                               │
         │                     │                                               │
         ▼                     ▼                                               │
    ┌─────────┐          ┌─────────────────┐                                   │
    │ code=0  │          │ code !== 0      │                                   │
    │ SUCCESS │          └────────┬────────┘                                   │
    └─────────┘                   │                                            │
                         ┌───────┴───────┐                                     │
                         ▼               ▼                                     │
              ┌──────────────────┐  ┌────────────────┐                          │
              │ hasValidOutput   │  │ !hasValidOutput │                          │
              │ (stdout非空)     │  │ (stdout为空)    │                          │
              └────────┬─────────┘  └───────┬────────┘                          │
                       │                    │                                   │
              ┌────────┴────────┐           │                                   │
              ▼                 ▼           ▼                                   │
       ┌─────────────┐   ┌───────────┐  ┌─────────┐                             │
       │!hasFatalError│   │hasFatalError│ │ ERROR   │                             │
       │ SUCCESS     │   │ ERROR      │  │ (无输出) │                             │
       │(宽容策略)   │   │(致命错误)  │  │         │                             │
       └─────────────┘   └───────────┘  └─────────┘                             │
                                                                              │
                    ┌──────────────────────────────────────────────────────────┘
                    │
                    ▼
             ┌─────────────┐
             │child.on('error')│
             │进程启动失败    │
             │REJECT        │
             └─────────────┘
```

### 核心错误处理代码

**1. 进程启动失败 (`child.on('error')`)**

```typescript
// 来源: cli-executor-core.ts:340-343
child.on('error', (error) => {
  currentChildProcess = null;
  reject(new Error(`Failed to spawn claude: ${error.message}`));
});
```

**处理场景**:
- CLI 工具未安装 (ENOENT)
- 权限不足 (EACCES)
- 系统资源不足

**2. 进程关闭处理 (`child.on('close')`)**

```typescript
// 来源: cli-executor-core.ts:1058-1091
let status: 'success' | 'error' = 'success';
if (code !== 0) {
  // 非零退出码不一定意味着失败
  // 检查是否有有效输出（AI 响应）- 视为成功
  const hasValidOutput = stdout.trim().length > 0;
  const hasFatalError = stderr.includes('FATAL') ||
                        stderr.includes('Authentication failed') ||
                        stderr.includes('API key') ||
                        stderr.includes('rate limit exceeded');

  debugLog('STATUS', `Non-zero exit code analysis`, {
    exitCode: code,
    hasValidOutput,
    hasFatalError,
    stderrPreview: stderr.substring(0, 500)
  });

  if (hasValidOutput && !hasFatalError) {
    // 有输出且无致命错误 - 尽管退出码非零仍视为成功
    status = 'success';
    debugLog('STATUS', `Treating as success (has valid output, no fatal errors)`);
  } else {
    status = 'error';
    errorLog('EXEC', `CLI execution failed`, undefined, {
      exitCode: code,
      tool,
      command,
      args,
      workingDir,
      stderrFull: stderr,
      stdoutPreview: stdout.substring(0, 200)
    });
  }
}
```

**宽容策略的设计哲学**:

> *"有些 CLI 工具在成功执行后仍返回非零退出码，比如它们想表达'任务完成但有警告'。如果 stdout 里有我们需要的答案， stderr 里没有致命错误，为什么要宣布失败？"*

### stderr 内容分类机制

```typescript
// 分类函数 (推断实现)
function classifyStderr(stderr: string): {
  severity: 'info' | 'warning' | 'error' | 'fatal';
  category: string;
  recoverable: boolean;
} {
  // 致命错误检测
  if (stderr.includes('FATAL') || 
      stderr.includes('Authentication failed')) {
    return { severity: 'fatal', category: 'auth', recoverable: false };
  }
  
  // 速率限制 - 可恢复
  if (stderr.includes('rate limit exceeded')) {
    return { severity: 'error', category: 'rate-limit', recoverable: true };
  }
  
  // API key 问题
  if (stderr.includes('API key')) {
    return { severity: 'error', category: 'config', recoverable: false };
  }
  
  // 调试/警告信息
  if (stderr.startsWith('[DEBUG]') || stderr.startsWith('[WARN]')) {
    return { severity: 'warning', category: 'debug', recoverable: true };
  }
  
  // 默认: 信息性
  return { severity: 'info', category: 'unknown', recoverable: true };
}
```

---

## 第三幕: 堆栈信息追踪与保留

### Python traceback 传递机制

Python 异常堆栈通过 stderr 以文本形式传递:

```python
# Python 端: 异常发生时
def process_request(data):
    result = json.loads(data)  # 这里可能抛出 JSONDecodeError
    return transform(result)

# traceback 输出到 stderr:
"""
Traceback (most recent call last):
  File "/app/cli.py", line 42, in <module>
    result = process_request(input_data)
  File "/app/cli.py", line 38, in process_request
    result = json.loads(data)
  File "/usr/lib/python3.10/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
  File "/usr/lib/python3.10/json/decoder.py", line 337, in decode
    obj = self.raw_decode(s, idx=_w(s, 0).end())[1]
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
"""
```

### TS 端堆栈处理逻辑

**1. `errorLog()` 函数 - 错误日志**

```typescript
// 来源: cli-executor-utils.ts:19-39
export function errorLog(
  category: string,
  message: string,
  error?: Error | unknown,
  context?: Record<string, unknown>
): void {
  const timestamp = new Date().toISOString();
  const prefix = `[${timestamp}] [CLI-ERROR] [${category}]`;
  console.error(`${prefix} ${message}`);
  
  if (error instanceof Error) {
    console.error(`${prefix} Error: ${error.message}`);
    // 堆栈只在 DEBUG 模式下输出
    if (isDebugEnabled() && error.stack) {
      console.error(`${prefix} Stack: ${error.stack}`);
    }
  } else if (error) {
    console.error(`${prefix} Error: ${String(error)}`);
  }
  
  if (context) {
    console.error(`${prefix} Context:`, JSON.stringify(context, null, 2));
  }
}
```

**2. `debugLog()` 函数 - 调试日志**

```typescript
// 来源: cli-executor-utils.ts:8-17
export function debugLog(category: string, message: string, data?: Record<string, unknown>): void {
  if (!isDebugEnabled()) return;
  const timestamp = new Date().toISOString();
  const prefix = `[${timestamp}] [CLI-DEBUG] [${category}]`;
  if (data) {
    console.error(`${prefix} ${message}`, JSON.stringify(data, null, 2));
  } else {
    console.error(`${prefix} ${message}`);
  }
}

// DEBUG 模式检测
export function isDebugEnabled(): boolean {
  return process.env.DEBUG === 'true' || 
         process.env.DEBUG === '1' || 
         process.env.CCW_DEBUG === 'true';
}
```

### 堆栈截断策略

```typescript
// 来源: cli-executor-core.ts:1111-1114
const newTurnOutput = {
  stdout: stdout.substring(0, 10240), // 截断预览到 10KB
  stderr: stderr.substring(0, 2048),  // 截断预览到 2KB
  truncated: stdout.length > 10240 || stderr.length > 2048,
  // 完整内容可选择缓存
  stdout_full: shouldCache ? stdout : undefined,
  stderr_full: shouldCache ? stderr : undefined,
};
```

**截断策略的幽灵线索**:

```markdown
问题: 当 Python traceback 包含多层调用和大型数据结构 repr 时，
      stderr 可能超过 2KB 截断限制，导致关键错误信息丢失。

场景:
  - 递归调用超过 100 层
  - 大型列表/字典的 repr 输出
  - 多个异常链 (exception chaining)

后果:
  - 真正的错误类型被截断
  - 调试者只能看到堆栈的开头部分
  - 无法定位真正的问题所在
```

**改进方案: 智能保留关键信息**

```typescript
// 建议实现: 保留首尾关键信息
function preserveStackTrace(stderr: string, maxSize: number = 2048): string {
  if (stderr.length <= maxSize) return stderr;
  
  const lines = stderr.split('\n');
  const errorLine = lines.find(l => 
    l.includes('Error:') || l.includes('Exception:')
  );
  
  // 策略: 保留头部 + 错误行 + 尾部
  const headLines = lines.slice(0, 5);
  const tailLines = lines.slice(-3);
  
  let result = headLines.join('\n');
  if (errorLine && !headLines.includes(errorLine)) {
    result += '\n...\n' + errorLine;
  }
  result += '\n...\n' + tailLines.join('\n');
  
  return result.slice(0, maxSize);
}
```

---

## 第四幕: 故障恢复机制

### 进程清理机制

```typescript
// 来源: cli-executor-core.ts:47-80
export function killCurrentCliProcess(): boolean {
  const child = currentChildProcess;
  if (!child || child.killed) return false;

  debugLog('KILL', 'Killing current child process', { pid: child.pid });

  try {
    child.kill('SIGTERM');  // 首先发送 SIGTERM (优雅终止)
  } catch {
    // 忽略 kill 错误 (进程可能已经退出)
  }

  // 清理之前的超时定时器
  if (killTimeout) {
    clearTimeout(killTimeout);
    killTimeout = null;
    killTimeoutProcess = null;
  }

  // 2 秒后强制终止
  killTimeoutProcess = child;
  killTimeout = setTimeout(() => {
    const target = killTimeoutProcess;
    if (!target || target !== currentChildProcess) return;
    if (target.killed) return;

    try {
      target.kill('SIGKILL');  // 强制终止
    } catch {
      // 忽略 kill 错误
    }
  }, 2000);

  return true;
}
```

**SIGTERM → SIGKILL 的优雅降级**:

```
┌─────────────────┐     SIGTERM      ┌─────────────────┐
│  TypeScript     │ ───────────────> │  Python 子进程  │
│  父进程         │                  │                 │
└────────┬────────┘                  └────────┬────────┘
         │                                    │
         │  2 秒等待                          │  优雅退出机会
         │                                    │  - 关闭文件句柄
         │                                    │  - 保存状态
         │                                    │  - 释放资源
         │  ┌─────────────────────────────────┘
         │  │
         │  │  进程仍在运行?
         │  ▼
         │  SIGKILL (强制终止)
         └──────────────────────────────────────>
                                             
         结果: 进程立即终止，资源由 OS 回收
```

### 降级模式: LiteLLM 路由

当 Python CLI 不可用时，系统可以降级到 API endpoint:

```typescript
// 来源: cli-executor-core.ts:476-528
// 检查 model 是否是自定义 LiteLLM endpoint ID
if (model) {
  const endpoint = findEndpointById(workingDir, model);
  if (endpoint) {
    // 路由到 LiteLLM executor (HTTP API)
    if (onOutput) {
      onOutput({
        type: 'stderr',
        content: `[Routing to LiteLLM endpoint: ${model}]\n`,
        timestamp: new Date().toISOString()
      });
    }

    const result = await executeLiteLLMEndpoint({
      prompt,
      endpointId: model,
      baseDir: workingDir,
      cwd: cd,
      includeDirs: includeDirs ? includeDirs.split(',').map(d => d.trim()) : undefined,
      enableCache: true,
      onOutput: onOutput || undefined,
    });
    // ...
  }
}
```

**降级策略对比**:

| 场景 | 主要方式 | 降级方式 | 触发条件 |
|------|----------|----------|----------|
| CLI 工具不可用 | 本地 CLI | API endpoint | `which` 找不到命令 |
| Python 环境问题 | 本地进程 | HTTP API | 启动失败/超时 |
| 认证失败 | 重试 | 用户提示 | `Authentication failed` |
| 速率限制 | 指数退避 | 切换 endpoint | `rate limit exceeded` |

### CLI 封装 Endpoint Fallback

```typescript
// 来源: litellm-executor.ts:297-306
// 检测速率限制
function isRateLimitError(errorMessage: string): boolean {
  return /429|rate limit|too many requests/i.test(errorMessage);
}

// 重试逻辑
// 重试速率限制、临时服务器错误和网络超时
async function executeWithRetry(/* ... */): Promise<Result> {
  const maxRetries = 3;
  const baseDelay = 1000;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await doExecute();
    } catch (error) {
      if (isRateLimitError(error.message)) {
        const delay = baseDelay * Math.pow(2, attempt);  // 指数退避
        await sleep(delay);
        continue;
      }
      throw error;
    }
  }
  throw new Error('Max retries exceeded');
}
```

---

## 第五幕: 事故复盘档案

### 案例研究: OOM 幽灵的诞生

```log
[03:47:12.003] CRITICAL ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[03:47:12.004] ! Memory allocation failed: 98.7% usage (15.8GB / 16GB)
[03:47:12.005] ! CLI Session Manager: subprocess SIGKILL (exit 137)
[03:47:12.006] ! SQLite: Database locked — 17 transactions rolled back
[03:47:12.007] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**幽灵线索追踪**:

```
Timeline:
  T+0h    用户执行长时间 CLI 任务 (Level 4 brainstorm)
  T+12h   Python 子进程产生大量 stderr 输出 (调试日志)
  T+24h   stderr 缓冲区开始累积，监听器消费速度 < 生产速度
  T+48h   子进程进入 BLOCKED 状态 (管道满，写入阻塞)
  T+60h   父进程持续等待，内存泄漏累积
  T+72h   OOM Killer 触发，进程被 SIGKILL

Root Cause:
  Python 未捕获异常 -> 大量 traceback 输出 -> stderr 管道满
  -> Python 写入阻塞 -> Node.js 端监听器未及时 drain
  -> 内存累积 -> OOM
```

**幽灵位置标注**:

```markdown
┌─────────────────────────────────────────────────────────────┐
│                    错误边界幽灵地图                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [Python 端]                                                │
│      │                                                      │
│      ▼                                                      │
│  未捕获异常 ──────────────────────────────┐                │
│      │                                     │                │
│      ▼                                     ▼                │
│  traceback.print_exc()              大量 stderr 输出        │
│      │                                     │                │
│      └─────────────────────────────────────┘                │
│                      │                                      │
│                      ▼                                      │
│  [边界层] stderr 管道 (16KB buffer)                         │
│                      │                                      │
│          ┌───────────┴───────────┐                         │
│          ▼                       ▼                         │
│    缓冲区满                   监听器消费                    │
│          │                       │                         │
│          ▼                       ▼                         │
│    Python BLOCKED          Node.js 事件循环                 │
│          │                       │                         │
│          └───────────────────────┘                         │
│                      │                                      │
│                      ▼                                      │
│  [TypeScript 端] 内存累积                                   │
│                      │                                      │
│                      ▼                                      │
│              OOM Killer                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 修复措施

**1. Python 端: 限制 traceback 输出**

```python
import sys
import traceback

def safe_execute(func, *args, **kwargs):
    try:
        return func(*args, **kwargs)
    except Exception as e:
        # 限制 traceback 深度
        tb_lines = traceback.format_exc().split('\n')[:20]
        limited_tb = '\n'.join(tb_lines)
        print(f"[ERROR] {type(e).__name__}: {e}", file=sys.stderr)
        print(limited_tb, file=sys.stderr)
        sys.exit(1)
```

**2. Node.js 端: 主动 drain stderr**

```typescript
// 持续消费 stderr，避免缓冲区满
child.stderr?.on('data', (data) => {
  stderr += data.toString();
  // 立即处理，避免缓冲区累积
  if (stderr.length > 65536) {  // 64KB 警告阈值
    debugLog('STDERR', 'Large stderr output detected', {
      length: stderr.length,
      preview: stderr.slice(-200)
    });
  }
});
```

**3. 超时保护**

```typescript
// 强制超时，避免无限等待
const TIMEOUT_MS = 30 * 60 * 1000;  // 30 分钟
const timeout = setTimeout(() => {
  debugLog('TIMEOUT', 'Execution timeout, killing process');
  killCurrentCliProcess();
}, TIMEOUT_MS);
```

---

## 调查进度条

```markdown
调查进度: ██████████ 65%
幽灵位置: 错误边界层 - Python stderr 缓冲区溢出导致进程假死
本章线索: 
  1. Python 未捕获异常 → 大量 traceback → stderr 满
  2. Node.js stderr 监听器未及时 drain → 缓冲区阻塞
  3. 子进程 BLOCKED → 父进程等待 → 内存累积
  4. 最终触发 OOM Killer

下一章线索: Chapter 10.8 - 会话持久化与恢复
           └── 当 OOM 发生时，如何保证会话状态不丢失？
```

---

## 附录: 错误处理速查表

### 快速诊断

| 症状 | 可能原因 | 检查命令 |
|------|----------|----------|
| `ENOENT` | CLI 工具未安装 | `which <tool>` |
| `EACCES` | 权限不足 | `ls -la <path>` |
| exit 137 | OOM/被 SIGKILL | `dmesg | grep -i kill` |
| exit 143 | 被 SIGTERM | 检查超时配置 |
| stderr 满 | 进程假死 | 检查 stderr 监听 |

### 调试命令

```bash
# 启用调试日志
DEBUG=true ccw cli -p "..." --tool gemini

# 检查 CLI 工具状态
ccw cli -p "test" --tool gemini --mode analysis 2>&1 | head -50

# 监控进程内存
ps aux | grep -E "(node|python|gemini)"

# 检查 stderr 缓冲区
lsof -p <pid> | grep pipe
```

---

> *"在错误边界的王国里，每个异常都是一个故事，每个堆栈追踪都是一条线索。我们的职责不是消灭错误，而是驯服它们，让它们成为系统韧性的基石。"*
>
> — 匿名架构师
