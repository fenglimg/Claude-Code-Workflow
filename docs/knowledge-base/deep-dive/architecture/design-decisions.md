# CCW 设计决策

> 关键技术决策的背景、权衡和理由

---

## 概述

本文档记录 CCW 项目的关键技术决策，包括：
- 决策背景
- 考虑的替代方案
- 选择理由
- 权衡分析

---

## 1. JSON-First 状态管理

### 背景
CCW 需要管理配置、会话状态、任务定义等多种状态数据。

### 决策
所有配置和会话状态使用 JSON 文件存储。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **SQLite** | 查询性能好 | 不可读、Git 不友好 |
| **YAML** | 更简洁 | 解析复杂、生态弱 |
| **项目级配置** | 项目隔离 | 多项目冲突 |

### 选择理由
1. **人类可读**: 开发者可直接阅读和编辑
2. **Git 友好**: diff 清晰，易于版本控制
3. **无需编译**: 运行时解析，即时生效
4. **全局配置**: `~/.claude/cli-tools.json` 用户级设置

### 权衡
- **优点**: 简单、透明、易于调试
- **代价**: 大量数据时性能不如数据库

### 文件位置
```
~/.claude/cli-tools.json     # CLI 工具配置
.workflow/sessions/**/*.json # 会话状态
.workflow/plans/**/*.json    # 任务计划
```

---

## 2. 多 CLI 工具策略

### 背景
不同 AI 模型在不同任务上表现各异，需要支持多种 CLI 工具。

### 决策
支持 Gemini、Qwen、Codex、Claude 等多种 CLI 工具，用户可通过 `--tool` 选择。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **单一工具** | 简单 | 无法利用模型优势 |
| **自动选择** | 无需用户决策 | 可能选错 |

### 选择理由
1. **模型特长**: Gemini 擅长分析，Codex 擅长代码，Claude 擅长推理
2. **用户选择**: 开发者可根据任务选择最佳工具
3. **成本优化**: 简单任务用廉价模型

### 配置示例
```json
{
  "tools": {
    "gemini": {
      "enabled": true,
      "primaryModel": "gemini-flash-latest",
      "type": "builtin"
    },
    "codex": {
      "enabled": true,
      "primaryModel": "gpt-5.2",
      "type": "builtin"
    }
  }
}
```

### 权衡
- **优点**: 灵活、可选择
- **代价**: 需要安装多个 CLI 工具

---

## 3. Phase-Based 技能结构

### 背景
复杂工作流需要清晰的执行顺序和阶段划分。

### 决策
技能采用 Phase-based 结构，使用数字前缀控制执行顺序。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **单文件技能** | 简单 | 难以维护 |
| **图结构** | 灵活 | 复杂度高 |
| **状态机** | 严格 | 不够灵活 |

### 选择理由
1. **清晰顺序**: `01-xxx.md`, `02-xxx.md` 一目了然
2. **支持子阶段**: `02.5-xxx.md` 插入中间步骤
3. **关注点分离**: phases/ 存逻辑，specs/ 存规范

### 目录结构
```
skill-name/
├── SKILL.md           # 入口
├── phases/            # 阶段
│   ├── 01-init.md
│   ├── 02-explore.md
│   └── 03-synthesis.md
├── specs/             # 规范
└── templates/         # 模板
```

### 权衡
- **优点**: 清晰、可维护
- **代价**: 文件数量多

---

## 4. SQLite 存储对话历史

### 背景
CLI 执行需要持久化对话历史，支持恢复和查询。

### 决策
对话历史使用 SQLite 存储（better-sqlite3）。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **JSONL** | 简单 | 查询性能差 |
| **LevelDB** | 快速 | 不可读 |
| **PostgreSQL** | 功能强大 | 依赖重 |

### 选择理由
1. **查询性能**: 支持索引查询
2. **同步 API**: better-sqlite3 提供同步接口
3. **嵌入式**: 无需额外服务

### 存储位置
```
~/.claude/conversations.db  # 对话历史
```

### 权衡
- **优点**: 性能好、功能强
- **代价**: 需要编译原生模块

---

## 5. TypeScript vs Python

### 背景
需要选择 CLI 和前端的技术栈。

### 决策
使用 TypeScript 作为主要开发语言。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **Python CLI + TS 前端** | 生态丰富 | 双语言维护 |
| **Go CLI** | 性能好 | 前后端分离 |
| **全 Python** | 简单 | 前端生态弱 |

### 选择理由
1. **单语言**: 前后端统一
2. **强类型**: 复杂状态的类型安全
3. **原生支持**: Node.js child_process 执行 CLI

### 权衡
- **优点**: 统一、类型安全
- **代价**: 部分生态不如 Python

---

## 6. Markdown 定义 Agent

### 背景
需要定义 21+ 个专用代理，配置需要人类可读。

### 决策
使用 Markdown + YAML Front Matter 定义代理配置。

### 替代方案
| 方案 | 优点 | 缺点 |
|------|------|------|
| **JSON 配置** | 解析简单 | 不可读 |
| **代码定义** | 灵活 | 需要编译 |
| **数据库** | 可查询 | 不透明 |

### 选择理由
1. **人类可读**: 开发者可直接阅读和编辑
2. **版本控制友好**: Git diff 清晰
3. **Claude 原生支持**: 可直接作为 system prompt 注入
4. **无需编译**: 运行时解析，即时生效

### 配置示例
```yaml
---
name: code-developer
description: |
  代码实现代理。专注于编写高质量代码。
color: green
allowed-tools: Task, Read, Write, Edit, Bash
---

You are a specialized agent for code implementation.
```

### 权衡
- **优点**: 透明、可读、即时生效
- **代价**: 解析略复杂

---

## 决策总结

| 决策 | 选择 | 核心理由 |
|------|------|----------|
| 状态管理 | JSON 文件 | 人类可读、Git 友好 |
| CLI 工具 | 多工具支持 | 利用模型优势 |
| 技能结构 | Phase-based | 清晰执行顺序 |
| 对话历史 | SQLite | 查询性能 |
| 开发语言 | TypeScript | 前后端统一 |
| Agent 定义 | Markdown | 人类可读、即时生效 |

---

## 相关资源

- [心智模型](mental-model.md) - 核心抽象
- [CLI 执行](../implementation/cli-execution.md) - 执行链路
- [代理生命周期](../implementation/agent-lifecycle.md) - 代理系统

---

*设计决策 - CCW Deep Dive*
